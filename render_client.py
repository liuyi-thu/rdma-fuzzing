# render_client.py
from jinja2 import Environment, FileSystemLoader

from lib import (
    ibv_all,  # 你的 ibv_all 模块
    verbs,  # 你的 verbs 模块
)
from lib.codegen_context import CodeGenContext  # 你的上下文

# from lib.value import DeferredValue  # 如果要检测 DeferredValue


def is_early_verb(v):
    # 不依赖远端参数的都可以提前执行：典型是 PostRecv、Create/Alloc/Reg 等
    return v.__class__.__name__ in {"PostRecv", "PollCQ"}  # 按需扩充


def needs_remote_gate(v):
    name = v.__class__.__name__
    # ModifyQP 到 RTR/RTS；PostSend(带 RDMA/ATOMIC/IMM/rkey)；Reg/Bind 里用到 rkey/remote_addr 的
    if name == "ModifyQP":
        # 简化：如果目标 state 在 {RTR,RTS} 就需要 gate
        attr = getattr(v, "attr_obj", None)
        if attr and getattr(attr, "qp_state", None):
            try:
                st = str(attr.qp_state.get_value())  # OptionalValue(EnumValue)
            except Exception:
                st = ""
            return ("RTR" in st) or ("RTS" in st)
        return False
    if name in {"PostSend"}:
        # 你的 IbvSendWR 里可检测 rdma/rkey/imm_data 等是否为 DeferredValue；这里简化：PostSend 统一 gate
        return True
    # RDMA READ/WRITE/ATOMIC 专用 verbs 也 gate
    return False


def collect_claim_meta(ctx):
    """
    从 ctx.tracker/ctx.contracts 中取出本地 QP/MR 的名字与属性，
    这里演示一个简化的映射：你可以从自己的 tracker 拿到地址/长度/lkey/qpn 等。
    """
    qps, mrs, pairs = [], [], []
    # 假设你在构造时知道一个 pair（cli0 <-> srv0），实际按序列扫描也可自动推断
    qps.append({"id": "cli0", "qpn": "qp0->qp_num", "psn": 0, "port": 1, "lid": 0, "gid": "00:...:00"})
    mrs.append({"id": "sbuf_cli0", "addr_expr": "mr0->addr", "length": 1024, "lkey": "mr0->lkey"})
    pairs.append({"id": "pair-cli0-srv0", "cli_id": "cli0", "srv_id": "srv0"})
    return qps, mrs, pairs


def render_client(verbs_list, template_dir=".", template_name="client_template.cpp.j2"):
    env = Environment(loader=FileSystemLoader(template_dir), trim_blocks=True, lstrip_blocks=True)
    tpl = env.get_template(template_name)

    ctx = CodeGenContext()
    early, body = [], []
    need_gate = False

    # 先 apply 一遍，构建上下文（变量注册/contract检查等）
    for v in verbs_list:
        v.apply(ctx)

    # 生成代码片段并分类
    for v in verbs_list:
        code = v.generate_c(ctx)
        (early if is_early_verb(v) else body).append(code)
        need_gate = need_gate or needs_remote_gate(v)

    # CLAIMED/READY 所需的元数据
    qps, mrs, pairs = collect_claim_meta(ctx)

    # 渲染
    cpp = tpl.render(
        compile_units="pair_runtime.cpp runtime_resolver.c -lcjson",
        output_name="rdma_client_autogen",
        ib_port=1,
        msg_size=1024,
        bundle_env="RDMA_FUZZ_RUNTIME",
        client_update="client_update.json",
        length=1000,
        setup_region="/* setup generated by verbs (alloc/reg/create) moved here if你把这些也用 generate_c 产出 */",
        early_verbs_region="".join(early),
        verbs_region="".join(body),
        epilog_region="/* optional CQ polling & cleanup */",
        prolog_extra="",  # 如果你想注入额外 helper，这里填
    )
    return cpp


if __name__ == "__main__":
    # 给个最小例：CreateQP→ModifyQP(RTR/RTS)→PostSend
    init_attr = ibv_all.IbvQPInitAttr(send_cq="cq0", recv_cq="cq0", cap=ibv_all.IbvQPCap(1, 1, 1, 1))
    seq = [
        verbs.AllocPD(pd="pd0"),
        verbs.CreateCQ(cqe=128, cq="cq0"),
        verbs.CreateQP(pd="pd0", qp="qp0", init_attr_obj=init_attr),
        verbs.ModifyQP(qp="qp0", attr_obj=verbs.IbvQPAttr(qp_state="IBV_QPS_RTR"), attr_mask="IBV_QP_STATE"),
        verbs.ModifyQP(qp="qp0", attr_obj=verbs.IbvQPAttr(qp_state="IBV_QPS_RTS"), attr_mask="IBV_QP_STATE"),
        verbs.PostSend(qp="qp0", wr_obj=verbs.IbvSendWR.random_mutation()),
    ]
    cpp = render_client(seq, template_dir=".", template_name="client_template_new.cpp.j2")
    with open("rdma_client_autogen.aaa.cpp", "w") as f:
        f.write(cpp)
    print("Wrote rdma_client_autogen.cpp")
