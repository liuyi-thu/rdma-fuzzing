// AUTOGEN: RDMA client (pairs + runtime) — generated by your fuzzer
// Toolchain: g++ -O2 -std=c++17 pair_runtime.cpp runtime_resolver.c -lcjson -libverbs -pthread -o rdma_client_autogen

#include <infiniband/verbs.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <thread>
#include <vector>
#include <string>
#include <algorithm>
#include <unistd.h>

#include "pair_runtime.h"
#include "runtime_resolver.h"

using std::string;
using std::vector;

static void die(const char* m){ perror(m); exit(1); }

// --------- User-configurable knobs (autofilled by generator) ----------
static const int IB_PORT = 1;
static const int MSG_SIZE = 1024;
static const char* BUNDLE_ENV = "RDMA_FUZZ_RUNTIME";
static const char* CLIENT_UPDATE_PATH = "client_update.json";

// --------- Prolog helper (optional; you can keep minimal) -------------
char bufs[1024][1024];
struct ibv_device ** dev_list;
struct ibv_context * ctx;
struct ibv_device_attr dev_attr;
struct ibv_port_attr port_attr;
union ibv_gid gid;
struct ibv_pd * pd1 = NULL;
struct ibv_pd * pd0 = NULL;
struct ibv_cq * cq1 = NULL;
struct ibv_pd * pd_25535 = NULL;
struct ibv_pd * pd_14069 = NULL;
struct ibv_pd * pd_36775 = NULL;
struct ibv_pd * pd_2691 = NULL;
struct ibv_cq * cq_43136 = NULL;
struct ibv_cq * cq0 = NULL;
struct ibv_qp * qp0 = NULL;
struct ibv_mr * mr0 = NULL;
struct ibv_srq * srq_37114;
struct ibv_pd * pd_30852 = NULL;
struct ibv_cq * cq_59698 = NULL;
struct ibv_qp * qp_688 = NULL;
struct ibv_mr * mr_38525 = NULL;
struct ibv_srq * srq_40224;
struct ibv_srq * srq_52708;
struct ibv_pd * pd_26196 = NULL;
struct ibv_srq * srq_56708;
struct ibv_pd * pd_22571 = NULL;
struct ibv_srq * srq_32963;
struct ibv_mr * mr1 = NULL;
struct ibv_pd * pd_50770 = NULL;
struct ibv_qp * qp_48807 = NULL;
struct ibv_cq * cq_28176 = NULL;
struct ibv_pd * pd_1893 = NULL;
struct ibv_pd * pd_27245 = NULL;
struct ibv_cq * cq_42368 = NULL;
struct ibv_cq * cq_6779 = NULL;
struct ibv_mr * mr_54721 = NULL;
struct ibv_srq * srq_527;
struct ibv_srq * srq_34909;
struct ibv_srq * srq_4458;
struct ibv_cq * cq_37403 = NULL;
struct ibv_qp * qp_23942 = NULL;
struct ibv_mr * mr_46984 = NULL;
struct ibv_mr * mr_48464 = NULL;
struct ibv_cq * cq_57283 = NULL;
struct ibv_mr * mr_35879 = NULL;
struct ibv_pd * pd_61783 = NULL;
struct ibv_cq * cq_2877 = NULL;
struct ibv_cq * cq_55148 = NULL;
struct ibv_mr * mr_19821 = NULL;
struct ibv_srq * srq0;
struct ibv_mr * mr_3172 = NULL;
struct ibv_qp * qp_15186 = NULL;
struct ibv_pd * pd_23514 = NULL;
struct ibv_cq * cq_43544 = NULL;
struct ibv_cq * cq_46499 = NULL;
struct ibv_mr * mr_26461 = NULL;
struct ibv_qp_init_attr attr_init_qp0;
struct ibv_qp_cap attr_init_qp0_cap;
struct ibv_qp_attr qp_attr_qp0;
struct ibv_ah_attr qp_attr_qp0_ah;
struct ibv_global_route qp_attr_qp0_ah_grh;
struct ibv_send_wr wr_qp0;
struct ibv_sge wr_qp0_sge_0;
struct ibv_send_wr * bad_wr_qp0 = NULL;
struct ibv_srq_init_attr srq_init_attr__37114;
struct ibv_srq_attr srq_init_attr__37114_attr;
struct ibv_modify_cq_attr modify_cq_attr;
struct ibv_moderate_cq modify_cq_attr_moderate;
struct ibv_qp_init_attr attr_init_qp_688;
struct ibv_qp_cap attr_init_qp_688_cap;
struct ibv_srq_init_attr srq_init_attr__40224;
struct ibv_srq_attr srq_init_attr__40224_attr;
struct ibv_srq_init_attr srq_init_attr__52708;
struct ibv_srq_attr srq_init_attr__52708_attr;
struct ibv_srq_init_attr srq_init_attr__56708;
struct ibv_srq_attr srq_init_attr__56708_attr;
struct ibv_srq_init_attr srq_init_attr__32963;
struct ibv_srq_attr srq_init_attr__32963_attr;
struct ibv_recv_wr recv_wr_srq_56708;
struct ibv_sge recv_wr_srq_56708_sge_0;
struct ibv_recv_wr recv_wr_srq_56708_next;
struct ibv_sge recv_wr_srq_56708_next_sge_0;
struct ibv_sge recv_wr_srq_56708_next_sge_1;
struct ibv_recv_wr * bad_recv_wr_srq_56708 = NULL;
struct ibv_recv_wr recv_wr_srq_32963;
struct ibv_sge recv_wr_srq_32963_sge_0;
struct ibv_recv_wr * bad_recv_wr_srq_32963 = NULL;
struct ibv_srq_attr srq_attr_srq_56708;
struct ibv_recv_wr recv_wr_srq_52708;
struct ibv_sge recv_wr_srq_52708_sge_0;
struct ibv_recv_wr * bad_recv_wr_srq_52708 = NULL;
struct ibv_qp_init_attr attr_init_qp_48807;
struct ibv_qp_cap attr_init_qp_48807_cap;
struct ibv_srq_attr srq_attr_srq_37114;
struct ibv_recv_wr recv_wr_srq_40224;
struct ibv_sge recv_wr_srq_40224_sge_0;
struct ibv_recv_wr * bad_recv_wr_srq_40224 = NULL;
struct ibv_srq_init_attr srq_init_attr__527;
struct ibv_srq_attr srq_init_attr__527_attr;
struct ibv_srq_init_attr srq_init_attr__34909;
struct ibv_srq_attr srq_init_attr__34909_attr;
struct ibv_srq_init_attr srq_init_attr__4458;
struct ibv_srq_attr srq_init_attr__4458_attr;
struct ibv_srq_attr srq_attr_srq_52708;
struct ibv_srq_attr srq_attr_srq_527;
struct ibv_qp_init_attr attr_init_qp_23942;
struct ibv_qp_cap attr_init_qp_23942_cap;
struct ibv_srq_attr srq_attr_srq_32963;
struct ibv_srq_init_attr srq_init_attr_0;
struct ibv_srq_attr srq_init_attr_0_attr;
struct ibv_srq_attr srq_attr_srq_40224;
struct ibv_qp_init_attr attr_init_qp_15186;
struct ibv_qp_cap attr_init_qp_15186_cap;

// --- Prepare PR_* for CLAIMED ---
PR_QP  qps[1000];
PR_MR  mrs[1000];
PR_Pair prs[1000];
int  qps_size;
int  mrs_size;
int  prs_size;

// ---------------------- main ----------------------
int main(int argc, char** argv){
    pr_init(BUNDLE_ENV);

    // --- Local buffers / MRs / QPs (generated) ---
    /* setup generated by verbs (alloc/reg/create) moved here if你把这些也用 generate_c 产出 */

    // --- Optional early verbs (don’t need remote params; e.g., PostRecv) ---
    

    // --- Main verbs body (generated) ---
        printf("[1] GetDeviceList(dev_list=dev_list) start.\n");

    /* ibv_get_device_list */
    dev_list = ibv_get_device_list(NULL);
    if (!dev_list) {
        fprintf(stderr, "Failed to get device list: %s\n", strerror(errno));
        return -1;
    }
    printf("[1] done.\n");

    printf("[2] OpenDevice(device=dev_list) start.\n");

    /* ibv_open_device */
    ctx = ibv_open_device(dev_list[0]);
    if (!ctx) {
        fprintf(stderr, "Failed to open device\n");
        return -1;
    }
    printf("[2] done.\n");

    printf("[3] FreeDeviceList(dev_list=dev_list, context=<lib.codegen_context.CodeGenContext object at...) start.\n");

    /* ibv_free_device_list */
    ibv_free_device_list(dev_list);
    printf("[3] done.\n");

    printf("[4] QueryDeviceAttr(output=dev_attr) start.\n");

    /* ibv_query_device */
    if (ibv_query_device(ctx, &dev_attr)) {
        fprintf(stderr, "Failed to query device attributes\n");
        return -1;
    }
    printf("[4] done.\n");

    printf("[5] QueryPortAttr(port_num=1) start.\n");

    /* ibv_query_port */
    if (ibv_query_port(ctx, 1, &port_attr)) {
        fprintf(stderr, "Failed to query port attributes\n");
        return -1;
    }
    printf("[5] done.\n");

    printf("[6] QueryGID(port_num=1, index=1) start.\n");

    /* ibv_query_gid */
    if (ibv_query_gid(ctx, 1, 1, &gid)) {
        fprintf(stderr, "Failed to query GID\n");
        return -1;
    }
    printf("[6] done.\n");

    printf("[7] AllocPD(pd=pd1) start.\n");

    /* ibv_alloc_pd */
    pd1 = ibv_alloc_pd(ctx);
    if (!pd1) {
        fprintf(stderr, "Failed to allocate protection domain\n");
        return -1;
    }
    printf("[7] done.\n");

    printf("[8] AllocPD(pd=pd0) start.\n");

    /* ibv_alloc_pd */
    pd0 = ibv_alloc_pd(ctx);
    if (!pd0) {
        fprintf(stderr, "Failed to allocate protection domain\n");
        return -1;
    }
    printf("[8] done.\n");

    printf("[9] CreateCQ(cqe=32, cq_context=NULL, channel=NULL, comp_vector=0, cq=cq1) start.\n");

    /* ibv_create_cq */
    cq1 = ibv_create_cq(ctx, 32, 
                              NULL, NULL, 
                              0);
    if (!cq1) {
        fprintf(stderr, "Failed to create completion queue\n");
        return -1;
    }
    printf("[9] done.\n");

    printf("[10] AllocPD(pd=pd_25535) start.\n");

    /* ibv_alloc_pd */
    pd_25535 = ibv_alloc_pd(ctx);
    if (!pd_25535) {
        fprintf(stderr, "Failed to allocate protection domain\n");
        return -1;
    }
    printf("[10] done.\n");

    printf("[11] AllocPD(pd=pd_14069) start.\n");

    /* ibv_alloc_pd */
    pd_14069 = ibv_alloc_pd(ctx);
    if (!pd_14069) {
        fprintf(stderr, "Failed to allocate protection domain\n");
        return -1;
    }
    printf("[11] done.\n");

    printf("[12] AllocPD(pd=pd_36775) start.\n");

    /* ibv_alloc_pd */
    pd_36775 = ibv_alloc_pd(ctx);
    if (!pd_36775) {
        fprintf(stderr, "Failed to allocate protection domain\n");
        return -1;
    }
    printf("[12] done.\n");

    printf("[13] AllocPD(pd=pd_2691) start.\n");

    /* ibv_alloc_pd */
    pd_2691 = ibv_alloc_pd(ctx);
    if (!pd_2691) {
        fprintf(stderr, "Failed to allocate protection domain\n");
        return -1;
    }
    printf("[13] done.\n");

    printf("[14] CreateCQ(cqe=16, cq_context=NULL, channel=NULL, comp_vector=0, cq=cq_43136) start.\n");

    /* ibv_create_cq */
    cq_43136 = ibv_create_cq(ctx, 16, 
                              NULL, NULL, 
                              0);
    if (!cq_43136) {
        fprintf(stderr, "Failed to create completion queue\n");
        return -1;
    }
    printf("[14] done.\n");

    printf("[15] CreateCQ(cqe=32, cq_context=NULL, channel=NULL, comp_vector=0, cq=cq0) start.\n");

    /* ibv_create_cq */
    cq0 = ibv_create_cq(ctx, 32, 
                              NULL, NULL, 
                              0);
    if (!cq0) {
        fprintf(stderr, "Failed to create completion queue\n");
        return -1;
    }
    printf("[15] done.\n");

    printf("[16] CreateQP(pd=pd1, qp=qp0, init_attr_obj=IbvQPInitAttr{send_cq=cq0, recv_cq=cq0, qp_type=IBV_QPT_UD, cap=IbvQPCap{max_send_wr=2, max_recv_wr=1, max_send_sge=1, max_recv_sge=1}, sq_sig_all=1}, remote_qp=srv0) start.\n");

    /* ibv_create_qp */
    
    memset(&attr_init_qp0, 0, sizeof(attr_init_qp0));
    attr_init_qp0.send_cq = cq0;
    attr_init_qp0.recv_cq = cq0;

    memset(&attr_init_qp0_cap, 0, sizeof(attr_init_qp0_cap));
    attr_init_qp0_cap.max_send_wr = 2;
    attr_init_qp0_cap.max_recv_wr = 1;
    attr_init_qp0_cap.max_send_sge = 1;
    attr_init_qp0_cap.max_recv_sge = 1;
    attr_init_qp0.cap = attr_init_qp0_cap;
    attr_init_qp0.qp_type = IBV_QPT_UD;
    attr_init_qp0.sq_sig_all = 1;

    qp0 = ibv_create_qp(pd1, &attr_init_qp0);
    if (!qp0) {
        fprintf(stderr, "Failed to create QP\n");
        return -1;
    }
    
    qps[qps_size++] = (PR_QP){
        .id = "qp0",
        .qpn = qp0->qp_num,
        .psn = 0,
        .port = 1,
        .lid = 0,
        .gid = "" // will set below
    };
    
    snprintf(qps[qps_size-1].gid, sizeof(qps[qps_size-1].gid),
                 "%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x",
                 gid.raw[0], gid.raw[1], gid.raw[2], gid.raw[3], gid.raw[4], gid.raw[5], gid.raw[6], gid.raw[7], gid.raw[8], gid.raw[9], gid.raw[10], gid.raw[11], gid.raw[12], gid.raw[13], gid.raw[14], gid.raw[15]);
                 
    prs[prs_size++] = (PR_Pair){
        .id = "pair-qp0-srv0",
        .cli_id = "qp0",
        .srv_id = "srv0"
    };
    
    pr_write_client_update_claimed(CLIENT_UPDATE_PATH, qps, qps_size, mrs, mrs_size, prs, prs_size);
    printf("[16] done.\n");

    printf("[17] ModifyQP(qp=qp0, attr_obj=IbvQPAttr{qp_state=IBV_QPS_INIT, dest_qp_num=rr_u32_by_id(\"remote.QP\", \"srv0\", \"qpn\"), port_num=1, qp_access_flags=IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WR..., pkey_index=0}, attr_mask=28690) start.\n");

    
    memset(&qp_attr_qp0, 0, sizeof(qp_attr_qp0));
    
    memset(&qp_attr_qp0, 0, sizeof(qp_attr_qp0));
    qp_attr_qp0.qp_state = IBV_QPS_INIT;
    qp_attr_qp0.dest_qp_num = rr_u32_by_id("remote.QP", "srv0", "qpn");
    qp_attr_qp0.qp_access_flags = IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE | IBV_ACCESS_LOCAL_WRITE;
    qp_attr_qp0.pkey_index = 0;
    qp_attr_qp0.port_num = 1;

    ibv_modify_qp(qp0, &qp_attr_qp0, 28690);
            printf("[17] done.\n");

    printf("[18] ModifyQP(qp=qp0, attr_obj=IbvQPAttr{qp_state=IBV_QPS_RTR, path_mtu=IBV_MTU_1024, dest_qp_num=rr_u32_by_id(\"remote.QP\", \"srv0\", \"qpn\"), rq_psn=0, max_dest_rd_atomic=1, min_rnr_timer=12, ah_attr=IbvAHAttr{dlid=rr_u32_by_id(\"remote.QP\", \"srv0\", \"lid\"), is_global=1, port_num=rr_u32_by_id(\"remote.QP\", \"srv0\", \"port\"), grh=IbvGlobalRoute{sgid_index=1, hop_limit=1, traffic_class=0, flow_label=0, dgid=rr_str_by_id(\"remote.QP\", \"srv0\", \"gid\")}, sl=0, src_path_bits=0}}, attr_mask=34994913) start.\n");

    pr_wait_pair_state(BUNDLE_ENV, "pair-qp0-srv0", "BOTH_RTS", /*timeout_ms=*/15000);
    memset(&qp_attr_qp0, 0, sizeof(qp_attr_qp0));
    
    memset(&qp_attr_qp0, 0, sizeof(qp_attr_qp0));
    qp_attr_qp0.qp_state = IBV_QPS_RTR;
    qp_attr_qp0.path_mtu = IBV_MTU_1024;
    qp_attr_qp0.rq_psn = 0;
    qp_attr_qp0.dest_qp_num = rr_u32_by_id("remote.QP", "srv0", "qpn");

    memset(&qp_attr_qp0_ah, 0, sizeof(qp_attr_qp0_ah));

    memset(&qp_attr_qp0_ah_grh, 0, sizeof(qp_attr_qp0_ah_grh));
    pr_parse_gid(rr_str_by_id("remote.QP", "srv0", "gid"), qp_attr_qp0_ah_grh.dgid.raw);
    qp_attr_qp0_ah_grh.flow_label = 0;
    qp_attr_qp0_ah_grh.sgid_index = 1;
    qp_attr_qp0_ah_grh.hop_limit = 1;
    qp_attr_qp0_ah_grh.traffic_class = 0;
    qp_attr_qp0_ah.grh = qp_attr_qp0_ah_grh;
    qp_attr_qp0_ah.dlid = rr_u32_by_id("remote.QP", "srv0", "lid");
    qp_attr_qp0_ah.sl = 0;
    qp_attr_qp0_ah.src_path_bits = 0;
    qp_attr_qp0_ah.is_global = 1;
    qp_attr_qp0_ah.port_num = rr_u32_by_id("remote.QP", "srv0", "port");
    qp_attr_qp0.ah_attr = qp_attr_qp0_ah;
    qp_attr_qp0.max_dest_rd_atomic = 1;
    qp_attr_qp0.min_rnr_timer = 12;

    ibv_modify_qp(qp0, &qp_attr_qp0, 34994913);
            printf("[18] done.\n");

    printf("[19] RegMR(pd=pd0, mr=mr0, addr=bufs[0], length=1024, access=IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_RE...) start.\n");

    /* ibv_reg_mr */
    mr0 = ibv_reg_mr(pd0, bufs[0], 1024, IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE);
    if (!mr0) {
        fprintf(stderr, "Failed to register memory region\n");
        return -1;
    }
    
    mrs[mrs_size++] = (PR_MR){
        .id = "mr0",
        .addr = (uint64_t)(mr0->addr),
        .length = 1024,
        .lkey = mr0->lkey};
        
    pr_write_client_update_claimed(CLIENT_UPDATE_PATH, qps, qps_size, mrs, mrs_size, prs, prs_size);
    
    printf("[19] done.\n");

    printf("[20] ModifyQP(qp=qp0, attr_obj=IbvQPAttr{qp_state=IBV_QPS_RTS, dest_qp_num=rr_u32_by_id(\"remote.QP\", \"srv0\", \"qpn\"), sq_psn=0, timeout=14, retry_cnt=7, rnr_retry=7, max_rd_atomic=1}, attr_mask=1881022) start.\n");

    
    memset(&qp_attr_qp0, 0, sizeof(qp_attr_qp0));
    
    memset(&qp_attr_qp0, 0, sizeof(qp_attr_qp0));
    qp_attr_qp0.qp_state = IBV_QPS_RTS;
    qp_attr_qp0.sq_psn = 0;
    qp_attr_qp0.dest_qp_num = rr_u32_by_id("remote.QP", "srv0", "qpn");
    qp_attr_qp0.max_rd_atomic = 1;
    qp_attr_qp0.timeout = 14;
    qp_attr_qp0.retry_cnt = 7;
    qp_attr_qp0.rnr_retry = 7;

    ibv_modify_qp(qp0, &qp_attr_qp0, 1881022);
            printf("[20] done.\n");

    printf("[21] PostSend(qp=qp0, wr_obj=IbvSendWR{opcode=IBV_WR_SEND, num_sge=1, sg_list=[IbvSge x1: IbvSge{addr=(uint64_t)mr0->addr, length=mr0->length, lkey=mr0->lkey}], wr_id=1, send_flags=IBV_SEND_SIGNALED}) start.\n");

    /* ibv_post_send */
    
    memset(&wr_qp0, 0, sizeof(wr_qp0));
    wr_qp0.wr_id = 1;

    memset(&wr_qp0_sge_0, 0, sizeof(wr_qp0_sge_0));
    wr_qp0_sge_0.addr = (uint64_t)mr0->addr;
    wr_qp0_sge_0.length = mr0->length;
    wr_qp0_sge_0.lkey = mr0->lkey;
    wr_qp0.sg_list = &wr_qp0_sge_0;
    wr_qp0.num_sge = 1;
    wr_qp0.opcode = IBV_WR_SEND;
    wr_qp0.send_flags = IBV_SEND_SIGNALED;

    if (ibv_post_send(qp0, &wr_qp0, &bad_wr_qp0) != 0) {
        fprintf(stderr, "Failed to post send work request\n");
        return -1;
    }
        printf("[21] done.\n");

    printf("[22] CreateSRQ(pd=pd1, srq=srq_37114, srq_init_obj=IbvSrqInitAttr{attr=IbvSrqAttr{max_wr=1, max_sge=1, srq_limit=0}}) start.\n");

    /* ibv_create_srq */
    
    memset(&srq_init_attr__37114, 0, sizeof(srq_init_attr__37114));

    memset(&srq_init_attr__37114_attr, 0, sizeof(srq_init_attr__37114_attr));
    srq_init_attr__37114_attr.max_wr = 1;
    srq_init_attr__37114_attr.max_sge = 1;
    srq_init_attr__37114_attr.srq_limit = 0;
    srq_init_attr__37114.attr = srq_init_attr__37114_attr;

    srq_37114 = ibv_create_srq(pd1, &srq_init_attr__37114);
    if (!srq_37114) {
        fprintf(stderr, "Failed to create SRQ\n");
        return -1;
    }
    printf("[22] done.\n");

    printf("[23] ModifyCQ(cq=cq_43136, attr_obj=IbvModifyCQAttr{attr_mask=0, moderate=IbvModerateCQ{cq_count=2, cq_period=1}}, attr_var=modify_cq_attr) start.\n");

    memset(&modify_cq_attr, 0, sizeof(modify_cq_attr));
    modify_cq_attr.attr_mask = 0;

    memset(&modify_cq_attr_moderate, 0, sizeof(modify_cq_attr_moderate));
    modify_cq_attr_moderate.cq_count = 2;
    modify_cq_attr_moderate.cq_period = 1;
    modify_cq_attr.moderate = modify_cq_attr_moderate;

    if (ibv_modify_cq(cq_43136, &modify_cq_attr) != 0) {
        fprintf(stderr, "ibv_modify_cq failed\n");
        return -1;
    }
    printf("[23] done.\n");

    printf("[24] DestroyCQ(cq=cq0) start.\n");

    /* ibv_destroy_cq */
    if (ibv_destroy_cq(cq0)) {
        fprintf(stderr, "Failed to destroy CQ\n");
        return -1;
    }
    printf("[24] done.\n");

    printf("[25] AllocPD(pd=pd_30852) start.\n");

    /* ibv_alloc_pd */
    pd_30852 = ibv_alloc_pd(ctx);
    if (!pd_30852) {
        fprintf(stderr, "Failed to allocate protection domain\n");
        return -1;
    }
    printf("[25] done.\n");

    printf("[26] PollCQ(cq=cq_43136) start.\n");

        /* ibv_poll_cq — self-contained minimal polling */
        {
            struct ibv_wc wc;
            int n = 0;
            int attempts = 100;   /* ~100 * 100us ≈ 10ms */
            while (attempts-- > 0) {
                n = ibv_poll_cq(cq_43136, 1, &wc);
                if (n < 0) {
                    fprintf(stderr, "ibv_poll_cq failed\n");
                    return -1;
                }
                if (n == 1) {
                    if (wc.status != IBV_WC_SUCCESS) {
                        fprintf(stderr, "bad completion: status=0x%x vendor=0x%x\n",
                                wc.status, wc.vendor_err);
                        return -1;
                    }
                    /* success – got one completion */
                    break;
                }
                /* n == 0: no CQE yet, back off briefly */
                usleep(100); /* 100us */
            }
            if (n == 0) {
                fprintf(stderr, "no completion within budget\n");
                return -1;
            }
        }
        printf("[26] done.\n");

    printf("[27] CreateCQ(cqe=16, cq_context=NULL, channel=NULL, comp_vector=0, cq=cq_59698) start.\n");

    /* ibv_create_cq */
    cq_59698 = ibv_create_cq(ctx, 16, 
                              NULL, NULL, 
                              0);
    if (!cq_59698) {
        fprintf(stderr, "Failed to create completion queue\n");
        return -1;
    }
    printf("[27] done.\n");

    printf("[28] DeallocPD(pd=pd_14069) start.\n");

    /* ibv_dealloc_pd */
    if (ibv_dealloc_pd(pd_14069)) {
        fprintf(stderr, "Failed to deallocate PD \n");
        return -1;
    }
    printf("[28] done.\n");

    printf("[29] CreateQP(pd=pd1, qp=qp_688, init_attr_obj=IbvQPInitAttr{recv_cq=cq_59698, qp_type=IBV_QPT_RC, cap=IbvQPCap{max_send_wr=1, max_recv_wr=1, max_send_sge=0, max_recv_sge=1}}, remote_qp=srv49) start.\n");

    /* ibv_create_qp */
    
    memset(&attr_init_qp_688, 0, sizeof(attr_init_qp_688));
    attr_init_qp_688.recv_cq = cq_59698;

    memset(&attr_init_qp_688_cap, 0, sizeof(attr_init_qp_688_cap));
    attr_init_qp_688_cap.max_send_wr = 1;
    attr_init_qp_688_cap.max_recv_wr = 1;
    attr_init_qp_688_cap.max_send_sge = 0;
    attr_init_qp_688_cap.max_recv_sge = 1;
    attr_init_qp_688.cap = attr_init_qp_688_cap;
    attr_init_qp_688.qp_type = IBV_QPT_RC;

    qp_688 = ibv_create_qp(pd1, &attr_init_qp_688);
    if (!qp_688) {
        fprintf(stderr, "Failed to create QP\n");
        return -1;
    }
    
    qps[qps_size++] = (PR_QP){
        .id = "qp_688",
        .qpn = qp_688->qp_num,
        .psn = 0,
        .port = 1,
        .lid = 0,
        .gid = "" // will set below
    };
    
    snprintf(qps[qps_size-1].gid, sizeof(qps[qps_size-1].gid),
                 "%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x",
                 gid.raw[0], gid.raw[1], gid.raw[2], gid.raw[3], gid.raw[4], gid.raw[5], gid.raw[6], gid.raw[7], gid.raw[8], gid.raw[9], gid.raw[10], gid.raw[11], gid.raw[12], gid.raw[13], gid.raw[14], gid.raw[15]);
                 
    prs[prs_size++] = (PR_Pair){
        .id = "pair-qp_688-srv49",
        .cli_id = "qp_688",
        .srv_id = "srv49"
    };
    
    pr_write_client_update_claimed(CLIENT_UPDATE_PATH, qps, qps_size, mrs, mrs_size, prs, prs_size);
    printf("[29] done.\n");

    printf("[30] RegMR(pd=pd1, mr=mr_38525, addr=bufs[20], length=4096, access=IBV_ACCESS_LOCAL_WRITE) start.\n");

    /* ibv_reg_mr */
    mr_38525 = ibv_reg_mr(pd1, bufs[20], 4096, IBV_ACCESS_LOCAL_WRITE);
    if (!mr_38525) {
        fprintf(stderr, "Failed to register memory region\n");
        return -1;
    }
    
    mrs[mrs_size++] = (PR_MR){
        .id = "mr_38525",
        .addr = (uint64_t)(mr_38525->addr),
        .length = 1024,
        .lkey = mr_38525->lkey};
        
    pr_write_client_update_claimed(CLIENT_UPDATE_PATH, qps, qps_size, mrs, mrs_size, prs, prs_size);
    
    printf("[30] done.\n");

    printf("[31] CreateSRQ(pd=pd1, srq=srq_40224, srq_init_obj=IbvSrqInitAttr{attr=IbvSrqAttr{max_wr=1, max_sge=1, srq_limit=0}}) start.\n");

    /* ibv_create_srq */
    
    memset(&srq_init_attr__40224, 0, sizeof(srq_init_attr__40224));

    memset(&srq_init_attr__40224_attr, 0, sizeof(srq_init_attr__40224_attr));
    srq_init_attr__40224_attr.max_wr = 1;
    srq_init_attr__40224_attr.max_sge = 1;
    srq_init_attr__40224_attr.srq_limit = 0;
    srq_init_attr__40224.attr = srq_init_attr__40224_attr;

    srq_40224 = ibv_create_srq(pd1, &srq_init_attr__40224);
    if (!srq_40224) {
        fprintf(stderr, "Failed to create SRQ\n");
        return -1;
    }
    printf("[31] done.\n");

    printf("[32] DestroyCQ(cq=cq1) start.\n");

    /* ibv_destroy_cq */
    if (ibv_destroy_cq(cq1)) {
        fprintf(stderr, "Failed to destroy CQ\n");
        return -1;
    }
    printf("[32] done.\n");

    printf("[33] CreateSRQ(pd=pd_25535, srq=srq_52708, srq_init_obj=IbvSrqInitAttr{attr=IbvSrqAttr{max_wr=1, max_sge=1, srq_limit=0}}) start.\n");

    /* ibv_create_srq */
    
    memset(&srq_init_attr__52708, 0, sizeof(srq_init_attr__52708));

    memset(&srq_init_attr__52708_attr, 0, sizeof(srq_init_attr__52708_attr));
    srq_init_attr__52708_attr.max_wr = 1;
    srq_init_attr__52708_attr.max_sge = 1;
    srq_init_attr__52708_attr.srq_limit = 0;
    srq_init_attr__52708.attr = srq_init_attr__52708_attr;

    srq_52708 = ibv_create_srq(pd_25535, &srq_init_attr__52708);
    if (!srq_52708) {
        fprintf(stderr, "Failed to create SRQ\n");
        return -1;
    }
    printf("[33] done.\n");

    printf("[34] AllocPD(pd=pd_26196) start.\n");

    /* ibv_alloc_pd */
    pd_26196 = ibv_alloc_pd(ctx);
    if (!pd_26196) {
        fprintf(stderr, "Failed to allocate protection domain\n");
        return -1;
    }
    printf("[34] done.\n");

    printf("[35] PollCQ(cq=cq_43136) start.\n");

        /* ibv_poll_cq — self-contained minimal polling */
        {
            struct ibv_wc wc;
            int n = 0;
            int attempts = 100;   /* ~100 * 100us ≈ 10ms */
            while (attempts-- > 0) {
                n = ibv_poll_cq(cq_43136, 1, &wc);
                if (n < 0) {
                    fprintf(stderr, "ibv_poll_cq failed\n");
                    return -1;
                }
                if (n == 1) {
                    if (wc.status != IBV_WC_SUCCESS) {
                        fprintf(stderr, "bad completion: status=0x%x vendor=0x%x\n",
                                wc.status, wc.vendor_err);
                        return -1;
                    }
                    /* success – got one completion */
                    break;
                }
                /* n == 0: no CQE yet, back off briefly */
                usleep(100); /* 100us */
            }
            if (n == 0) {
                fprintf(stderr, "no completion within budget\n");
                return -1;
            }
        }
        printf("[35] done.\n");

    printf("[36] CreateSRQ(pd=pd1, srq=srq_56708, srq_init_obj=IbvSrqInitAttr{attr=IbvSrqAttr{max_wr=1, max_sge=1, srq_limit=0}}) start.\n");

    /* ibv_create_srq */
    
    memset(&srq_init_attr__56708, 0, sizeof(srq_init_attr__56708));

    memset(&srq_init_attr__56708_attr, 0, sizeof(srq_init_attr__56708_attr));
    srq_init_attr__56708_attr.max_wr = 1;
    srq_init_attr__56708_attr.max_sge = 1;
    srq_init_attr__56708_attr.srq_limit = 0;
    srq_init_attr__56708.attr = srq_init_attr__56708_attr;

    srq_56708 = ibv_create_srq(pd1, &srq_init_attr__56708);
    if (!srq_56708) {
        fprintf(stderr, "Failed to create SRQ\n");
        return -1;
    }
    printf("[36] done.\n");

    printf("[37] AllocPD(pd=pd_22571) start.\n");

    /* ibv_alloc_pd */
    pd_22571 = ibv_alloc_pd(ctx);
    if (!pd_22571) {
        fprintf(stderr, "Failed to allocate protection domain\n");
        return -1;
    }
    printf("[37] done.\n");

    printf("[38] PollCQ(cq=cq_43136) start.\n");

        /* ibv_poll_cq — self-contained minimal polling */
        {
            struct ibv_wc wc;
            int n = 0;
            int attempts = 100;   /* ~100 * 100us ≈ 10ms */
            while (attempts-- > 0) {
                n = ibv_poll_cq(cq_43136, 1, &wc);
                if (n < 0) {
                    fprintf(stderr, "ibv_poll_cq failed\n");
                    return -1;
                }
                if (n == 1) {
                    if (wc.status != IBV_WC_SUCCESS) {
                        fprintf(stderr, "bad completion: status=0x%x vendor=0x%x\n",
                                wc.status, wc.vendor_err);
                        return -1;
                    }
                    /* success – got one completion */
                    break;
                }
                /* n == 0: no CQE yet, back off briefly */
                usleep(100); /* 100us */
            }
            if (n == 0) {
                fprintf(stderr, "no completion within budget\n");
                return -1;
            }
        }
        printf("[38] done.\n");

    printf("[39] CreateSRQ(pd=pd1, srq=srq_32963, srq_init_obj=IbvSrqInitAttr{attr=IbvSrqAttr{max_wr=1, max_sge=1, srq_limit=0}}) start.\n");

    /* ibv_create_srq */
    
    memset(&srq_init_attr__32963, 0, sizeof(srq_init_attr__32963));

    memset(&srq_init_attr__32963_attr, 0, sizeof(srq_init_attr__32963_attr));
    srq_init_attr__32963_attr.max_wr = 1;
    srq_init_attr__32963_attr.max_sge = 1;
    srq_init_attr__32963_attr.srq_limit = 0;
    srq_init_attr__32963.attr = srq_init_attr__32963_attr;

    srq_32963 = ibv_create_srq(pd1, &srq_init_attr__32963);
    if (!srq_32963) {
        fprintf(stderr, "Failed to create SRQ\n");
        return -1;
    }
    printf("[39] done.\n");

    printf("[40] RegMR(pd=pd1, mr=mr1, addr=bufs[1], length=1025, access=IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_RE...) start.\n");

    /* ibv_reg_mr */
    mr1 = ibv_reg_mr(pd1, bufs[1], 1025, IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE);
    if (!mr1) {
        fprintf(stderr, "Failed to register memory region\n");
        return -1;
    }
    
    mrs[mrs_size++] = (PR_MR){
        .id = "mr1",
        .addr = (uint64_t)(mr1->addr),
        .length = 1024,
        .lkey = mr1->lkey};
        
    pr_write_client_update_claimed(CLIENT_UPDATE_PATH, qps, qps_size, mrs, mrs_size, prs, prs_size);
    
    printf("[40] done.\n");

    printf("[41] ModifyCQ(cq=cq_43136, attr_obj=IbvModifyCQAttr{attr_mask=0, moderate=IbvModerateCQ{cq_count=1, cq_period=1}}, attr_var=modify_cq_attr) start.\n");

    memset(&modify_cq_attr, 0, sizeof(modify_cq_attr));
    modify_cq_attr.attr_mask = 0;

    memset(&modify_cq_attr_moderate, 0, sizeof(modify_cq_attr_moderate));
    modify_cq_attr_moderate.cq_count = 1;
    modify_cq_attr_moderate.cq_period = 1;
    modify_cq_attr.moderate = modify_cq_attr_moderate;

    if (ibv_modify_cq(cq_43136, &modify_cq_attr) != 0) {
        fprintf(stderr, "ibv_modify_cq failed\n");
        return -1;
    }
    printf("[41] done.\n");

    printf("[42] PostSRQRecv(srq=srq_56708, wr_obj=IbvRecvWR{num_sge=1, sg_list=[IbvSge x1: IbvSge{addr=\u2205, length=\u2205, lkey=\u2205}], next=IbvRecvWR{num_sge=2, sg_list=[IbvSge x2: IbvSge{addr=\u2205, length=\u2205, lkey=\u2205}], wr_id=4193735974424621272}}, wr_var=recv_wr_srq_56708, bad_wr_var=bad_recv_wr_srq_56708) start.\n");

    memset(&recv_wr_srq_56708, 0, sizeof(recv_wr_srq_56708));

    memset(&recv_wr_srq_56708_sge_0, 0, sizeof(recv_wr_srq_56708_sge_0));
    recv_wr_srq_56708.sg_list = &recv_wr_srq_56708_sge_0;
    recv_wr_srq_56708.num_sge = 1;

    memset(&recv_wr_srq_56708_next, 0, sizeof(recv_wr_srq_56708_next));
    recv_wr_srq_56708_next.wr_id = 4193735974424621272;

    memset(&recv_wr_srq_56708_next_sge_0, 0, sizeof(recv_wr_srq_56708_next_sge_0));

    memset(&recv_wr_srq_56708_next_sge_1, 0, sizeof(recv_wr_srq_56708_next_sge_1));
    recv_wr_srq_56708_next.sg_list = &recv_wr_srq_56708_next_sge_0;
    recv_wr_srq_56708_next.num_sge = 2;
    recv_wr_srq_56708_next.next = NULL;
    recv_wr_srq_56708.next = &recv_wr_srq_56708_next;

    if (ibv_post_srq_recv(srq_56708, &recv_wr_srq_56708, &bad_recv_wr_srq_56708) != 0) {
        fprintf(stderr, "ibv_post_srq_recv failed\n");
        return -1;
    }
    printf("[42] done.\n");

    printf("[43] DeallocPD(pd=pd_25535) start.\n");

    /* ibv_dealloc_pd */
    if (ibv_dealloc_pd(pd_25535)) {
        fprintf(stderr, "Failed to deallocate PD \n");
        return -1;
    }
    printf("[43] done.\n");

    printf("[44] PostSRQRecv(srq=srq_32963, wr_obj=IbvRecvWR{num_sge=1, sg_list=[IbvSge x1: IbvSge{addr=\u2205, length=\u2205, lkey=\u2205}]}, wr_var=recv_wr_srq_32963, bad_wr_var=bad_recv_wr_srq_32963) start.\n");

    memset(&recv_wr_srq_32963, 0, sizeof(recv_wr_srq_32963));

    memset(&recv_wr_srq_32963_sge_0, 0, sizeof(recv_wr_srq_32963_sge_0));
    recv_wr_srq_32963.sg_list = &recv_wr_srq_32963_sge_0;
    recv_wr_srq_32963.num_sge = 1;
    recv_wr_srq_32963.next = NULL;

    if (ibv_post_srq_recv(srq_32963, &recv_wr_srq_32963, &bad_recv_wr_srq_32963) != 0) {
        fprintf(stderr, "ibv_post_srq_recv failed\n");
        return -1;
    }
    printf("[44] done.\n");

    printf("[45] DestroyQP(qp=qp_688) start.\n");

    /* ibv_destroy_qp */
    if (ibv_destroy_qp(qp_688)) {
        fprintf(stderr, "Failed to destroy QP\n");
        return -1;
    }
    printf("[45] done.\n");

    printf("[46] AllocPD(pd=pd_50770) start.\n");

    /* ibv_alloc_pd */
    pd_50770 = ibv_alloc_pd(ctx);
    if (!pd_50770) {
        fprintf(stderr, "Failed to allocate protection domain\n");
        return -1;
    }
    printf("[46] done.\n");

    printf("[47] ModifySRQ(srq=srq_56708, attr_var=srq_attr_srq_56708, attr_obj=IbvSrqAttr{max_wr=1, srq_limit=0}, attr_mask=IBV_SRQ_MAX_WR | IBV_SRQ_LIMIT) start.\n");

    memset(&srq_attr_srq_56708, 0, sizeof(srq_attr_srq_56708));
    srq_attr_srq_56708.max_wr = 1;
    srq_attr_srq_56708.srq_limit = 0;

    if (ibv_modify_srq(srq_56708, &srq_attr_srq_56708, IBV_SRQ_MAX_WR | IBV_SRQ_LIMIT) != 0) {
        fprintf(stderr, "ibv_modify_srq failed\n");
        return -1;
    }
    printf("[47] done.\n");

    printf("[48] PostSRQRecv(srq=srq_52708, wr_obj=IbvRecvWR{num_sge=1, sg_list=[IbvSge x1: IbvSge{addr=\u2205, length=\u2205, lkey=\u2205}]}, wr_var=recv_wr_srq_52708, bad_wr_var=bad_recv_wr_srq_52708) start.\n");

    memset(&recv_wr_srq_52708, 0, sizeof(recv_wr_srq_52708));

    memset(&recv_wr_srq_52708_sge_0, 0, sizeof(recv_wr_srq_52708_sge_0));
    recv_wr_srq_52708.sg_list = &recv_wr_srq_52708_sge_0;
    recv_wr_srq_52708.num_sge = 1;
    recv_wr_srq_52708.next = NULL;

    if (ibv_post_srq_recv(srq_52708, &recv_wr_srq_52708, &bad_recv_wr_srq_52708) != 0) {
        fprintf(stderr, "ibv_post_srq_recv failed\n");
        return -1;
    }
    printf("[48] done.\n");

    printf("[49] PollCQ(cq=cq_59698) start.\n");

        /* ibv_poll_cq — self-contained minimal polling */
        {
            struct ibv_wc wc;
            int n = 0;
            int attempts = 100;   /* ~100 * 100us ≈ 10ms */
            while (attempts-- > 0) {
                n = ibv_poll_cq(cq_59698, 1, &wc);
                if (n < 0) {
                    fprintf(stderr, "ibv_poll_cq failed\n");
                    return -1;
                }
                if (n == 1) {
                    if (wc.status != IBV_WC_SUCCESS) {
                        fprintf(stderr, "bad completion: status=0x%x vendor=0x%x\n",
                                wc.status, wc.vendor_err);
                        return -1;
                    }
                    /* success – got one completion */
                    break;
                }
                /* n == 0: no CQE yet, back off briefly */
                usleep(100); /* 100us */
            }
            if (n == 0) {
                fprintf(stderr, "no completion within budget\n");
                return -1;
            }
        }
        printf("[49] done.\n");

    printf("[50] DeallocPD(pd=pd_50770) start.\n");

    /* ibv_dealloc_pd */
    if (ibv_dealloc_pd(pd_50770)) {
        fprintf(stderr, "Failed to deallocate PD \n");
        return -1;
    }
    printf("[50] done.\n");

    printf("[51] CreateQP(pd=pd_2691, qp=qp_48807, init_attr_obj=IbvQPInitAttr{send_cq=cq_43136, recv_cq=cq_43136, qp_type=IBV_QPT_RC, cap=IbvQPCap{max_send_wr=1, max_recv_wr=1, max_send_sge=1, max_recv_sge=1}}, remote_qp=srv41) start.\n");

    /* ibv_create_qp */
    
    memset(&attr_init_qp_48807, 0, sizeof(attr_init_qp_48807));
    attr_init_qp_48807.send_cq = cq_43136;
    attr_init_qp_48807.recv_cq = cq_43136;

    memset(&attr_init_qp_48807_cap, 0, sizeof(attr_init_qp_48807_cap));
    attr_init_qp_48807_cap.max_send_wr = 1;
    attr_init_qp_48807_cap.max_recv_wr = 1;
    attr_init_qp_48807_cap.max_send_sge = 1;
    attr_init_qp_48807_cap.max_recv_sge = 1;
    attr_init_qp_48807.cap = attr_init_qp_48807_cap;
    attr_init_qp_48807.qp_type = IBV_QPT_RC;

    qp_48807 = ibv_create_qp(pd_2691, &attr_init_qp_48807);
    if (!qp_48807) {
        fprintf(stderr, "Failed to create QP\n");
        return -1;
    }
    
    qps[qps_size++] = (PR_QP){
        .id = "qp_48807",
        .qpn = qp_48807->qp_num,
        .psn = 0,
        .port = 1,
        .lid = 0,
        .gid = "" // will set below
    };
    
    snprintf(qps[qps_size-1].gid, sizeof(qps[qps_size-1].gid),
                 "%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x",
                 gid.raw[0], gid.raw[1], gid.raw[2], gid.raw[3], gid.raw[4], gid.raw[5], gid.raw[6], gid.raw[7], gid.raw[8], gid.raw[9], gid.raw[10], gid.raw[11], gid.raw[12], gid.raw[13], gid.raw[14], gid.raw[15]);
                 
    prs[prs_size++] = (PR_Pair){
        .id = "pair-qp_48807-srv41",
        .cli_id = "qp_48807",
        .srv_id = "srv41"
    };
    
    pr_write_client_update_claimed(CLIENT_UPDATE_PATH, qps, qps_size, mrs, mrs_size, prs, prs_size);
    printf("[51] done.\n");

    printf("[52] PostSRQRecv(srq=srq_32963, wr_obj=IbvRecvWR{num_sge=1, sg_list=[IbvSge x1: IbvSge{addr=\u2205, length=\u2205, lkey=\u2205}]}, wr_var=recv_wr_srq_32963, bad_wr_var=bad_recv_wr_srq_32963) start.\n");

    memset(&recv_wr_srq_32963, 0, sizeof(recv_wr_srq_32963));

    memset(&recv_wr_srq_32963_sge_0, 0, sizeof(recv_wr_srq_32963_sge_0));
    recv_wr_srq_32963.sg_list = &recv_wr_srq_32963_sge_0;
    recv_wr_srq_32963.num_sge = 1;
    recv_wr_srq_32963.next = NULL;

    if (ibv_post_srq_recv(srq_32963, &recv_wr_srq_32963, &bad_recv_wr_srq_32963) != 0) {
        fprintf(stderr, "ibv_post_srq_recv failed\n");
        return -1;
    }
    printf("[52] done.\n");

    printf("[53] DeregMR(mr=mr_38525) start.\n");

    /* ibv_dereg_mr */
    if (ibv_dereg_mr(mr_38525)) {
        fprintf(stderr, "Failed to deregister MR\n");
        return -1;
    }
    printf("[53] done.\n");

    printf("[54] CreateCQ(cqe=16, cq_context=NULL, channel=NULL, comp_vector=0, cq=cq_28176) start.\n");

    /* ibv_create_cq */
    cq_28176 = ibv_create_cq(ctx, 16, 
                              NULL, NULL, 
                              0);
    if (!cq_28176) {
        fprintf(stderr, "Failed to create completion queue\n");
        return -1;
    }
    printf("[54] done.\n");

    printf("[55] DeregMR(mr=mr1) start.\n");

    /* ibv_dereg_mr */
    if (ibv_dereg_mr(mr1)) {
        fprintf(stderr, "Failed to deregister MR\n");
        return -1;
    }
    printf("[55] done.\n");

    printf("[56] PostSRQRecv(srq=srq_56708, wr_obj=IbvRecvWR{num_sge=1, sg_list=[IbvSge x1: IbvSge{addr=\u2205, length=\u2205, lkey=\u2205}]}, wr_var=recv_wr_srq_56708, bad_wr_var=bad_recv_wr_srq_56708) start.\n");

    memset(&recv_wr_srq_56708, 0, sizeof(recv_wr_srq_56708));

    memset(&recv_wr_srq_56708_sge_0, 0, sizeof(recv_wr_srq_56708_sge_0));
    recv_wr_srq_56708.sg_list = &recv_wr_srq_56708_sge_0;
    recv_wr_srq_56708.num_sge = 1;
    recv_wr_srq_56708.next = NULL;

    if (ibv_post_srq_recv(srq_56708, &recv_wr_srq_56708, &bad_recv_wr_srq_56708) != 0) {
        fprintf(stderr, "ibv_post_srq_recv failed\n");
        return -1;
    }
    printf("[56] done.\n");

    printf("[57] DestroyQP(qp=qp_48807) start.\n");

    /* ibv_destroy_qp */
    if (ibv_destroy_qp(qp_48807)) {
        fprintf(stderr, "Failed to destroy QP\n");
        return -1;
    }
    printf("[57] done.\n");

    printf("[58] DeregMR(mr=mr0) start.\n");

    /* ibv_dereg_mr */
    if (ibv_dereg_mr(mr0)) {
        fprintf(stderr, "Failed to deregister MR\n");
        return -1;
    }
    printf("[58] done.\n");

    printf("[59] DeallocPD(pd=pd_26196) start.\n");

    /* ibv_dealloc_pd */
    if (ibv_dealloc_pd(pd_26196)) {
        fprintf(stderr, "Failed to deallocate PD \n");
        return -1;
    }
    printf("[59] done.\n");

    printf("[60] ModifySRQ(srq=srq_37114, attr_var=srq_attr_srq_37114, attr_obj=IbvSrqAttr{max_wr=1, srq_limit=0}, attr_mask=IBV_SRQ_MAX_WR | IBV_SRQ_LIMIT) start.\n");

    memset(&srq_attr_srq_37114, 0, sizeof(srq_attr_srq_37114));
    srq_attr_srq_37114.max_wr = 1;
    srq_attr_srq_37114.srq_limit = 0;

    if (ibv_modify_srq(srq_37114, &srq_attr_srq_37114, IBV_SRQ_MAX_WR | IBV_SRQ_LIMIT) != 0) {
        fprintf(stderr, "ibv_modify_srq failed\n");
        return -1;
    }
    printf("[60] done.\n");

    printf("[61] ModifyCQ(cq=cq_43136, attr_obj=IbvModifyCQAttr{attr_mask=0, moderate=IbvModerateCQ{cq_count=1, cq_period=1}}, attr_var=modify_cq_attr) start.\n");

    memset(&modify_cq_attr, 0, sizeof(modify_cq_attr));
    modify_cq_attr.attr_mask = 0;

    memset(&modify_cq_attr_moderate, 0, sizeof(modify_cq_attr_moderate));
    modify_cq_attr_moderate.cq_count = 1;
    modify_cq_attr_moderate.cq_period = 1;
    modify_cq_attr.moderate = modify_cq_attr_moderate;

    if (ibv_modify_cq(cq_43136, &modify_cq_attr) != 0) {
        fprintf(stderr, "ibv_modify_cq failed\n");
        return -1;
    }
    printf("[61] done.\n");

    printf("[62] DestroyCQ(cq=cq_28176) start.\n");

    /* ibv_destroy_cq */
    if (ibv_destroy_cq(cq_28176)) {
        fprintf(stderr, "Failed to destroy CQ\n");
        return -1;
    }
    printf("[62] done.\n");

    printf("[63] PostSRQRecv(srq=srq_40224, wr_obj=IbvRecvWR{num_sge=1, sg_list=[IbvSge x1: IbvSge{addr=\u2205, length=\u2205, lkey=\u2205}]}, wr_var=recv_wr_srq_40224, bad_wr_var=bad_recv_wr_srq_40224) start.\n");

    memset(&recv_wr_srq_40224, 0, sizeof(recv_wr_srq_40224));

    memset(&recv_wr_srq_40224_sge_0, 0, sizeof(recv_wr_srq_40224_sge_0));
    recv_wr_srq_40224.sg_list = &recv_wr_srq_40224_sge_0;
    recv_wr_srq_40224.num_sge = 1;
    recv_wr_srq_40224.next = NULL;

    if (ibv_post_srq_recv(srq_40224, &recv_wr_srq_40224, &bad_recv_wr_srq_40224) != 0) {
        fprintf(stderr, "ibv_post_srq_recv failed\n");
        return -1;
    }
    printf("[63] done.\n");

    printf("[64] PostSRQRecv(srq=srq_32963, wr_obj=IbvRecvWR{num_sge=1, sg_list=[IbvSge x1: IbvSge{addr=\u2205, length=\u2205, lkey=\u2205}]}, wr_var=recv_wr_srq_32963, bad_wr_var=bad_recv_wr_srq_32963) start.\n");

    memset(&recv_wr_srq_32963, 0, sizeof(recv_wr_srq_32963));

    memset(&recv_wr_srq_32963_sge_0, 0, sizeof(recv_wr_srq_32963_sge_0));
    recv_wr_srq_32963.sg_list = &recv_wr_srq_32963_sge_0;
    recv_wr_srq_32963.num_sge = 1;
    recv_wr_srq_32963.next = NULL;

    if (ibv_post_srq_recv(srq_32963, &recv_wr_srq_32963, &bad_recv_wr_srq_32963) != 0) {
        fprintf(stderr, "ibv_post_srq_recv failed\n");
        return -1;
    }
    printf("[64] done.\n");

    printf("[65] AllocPD(pd=pd_1893) start.\n");

    /* ibv_alloc_pd */
    pd_1893 = ibv_alloc_pd(ctx);
    if (!pd_1893) {
        fprintf(stderr, "Failed to allocate protection domain\n");
        return -1;
    }
    printf("[65] done.\n");

    printf("[66] AllocPD(pd=pd_27245) start.\n");

    /* ibv_alloc_pd */
    pd_27245 = ibv_alloc_pd(ctx);
    if (!pd_27245) {
        fprintf(stderr, "Failed to allocate protection domain\n");
        return -1;
    }
    printf("[66] done.\n");

    printf("[67] PostSRQRecv(srq=srq_56708, wr_obj=IbvRecvWR{num_sge=1, sg_list=[IbvSge x1: IbvSge{addr=\u2205, length=\u2205, lkey=\u2205}]}, wr_var=recv_wr_srq_56708, bad_wr_var=bad_recv_wr_srq_56708) start.\n");

    memset(&recv_wr_srq_56708, 0, sizeof(recv_wr_srq_56708));

    memset(&recv_wr_srq_56708_sge_0, 0, sizeof(recv_wr_srq_56708_sge_0));
    recv_wr_srq_56708.sg_list = &recv_wr_srq_56708_sge_0;
    recv_wr_srq_56708.num_sge = 1;
    recv_wr_srq_56708.next = NULL;

    if (ibv_post_srq_recv(srq_56708, &recv_wr_srq_56708, &bad_recv_wr_srq_56708) != 0) {
        fprintf(stderr, "ibv_post_srq_recv failed\n");
        return -1;
    }
    printf("[67] done.\n");

    printf("[68] CreateCQ(cqe=16, cq_context=NULL, channel=NULL, comp_vector=0, cq=cq_42368) start.\n");

    /* ibv_create_cq */
    cq_42368 = ibv_create_cq(ctx, 16, 
                              NULL, NULL, 
                              0);
    if (!cq_42368) {
        fprintf(stderr, "Failed to create completion queue\n");
        return -1;
    }
    printf("[68] done.\n");

    printf("[69] CreateCQ(cqe=16, cq_context=NULL, channel=NULL, comp_vector=0, cq=cq_6779) start.\n");

    /* ibv_create_cq */
    cq_6779 = ibv_create_cq(ctx, 16, 
                              NULL, NULL, 
                              0);
    if (!cq_6779) {
        fprintf(stderr, "Failed to create completion queue\n");
        return -1;
    }
    printf("[69] done.\n");

    printf("[70] PollCQ(cq=cq_42368) start.\n");

        /* ibv_poll_cq — self-contained minimal polling */
        {
            struct ibv_wc wc;
            int n = 0;
            int attempts = 100;   /* ~100 * 100us ≈ 10ms */
            while (attempts-- > 0) {
                n = ibv_poll_cq(cq_42368, 1, &wc);
                if (n < 0) {
                    fprintf(stderr, "ibv_poll_cq failed\n");
                    return -1;
                }
                if (n == 1) {
                    if (wc.status != IBV_WC_SUCCESS) {
                        fprintf(stderr, "bad completion: status=0x%x vendor=0x%x\n",
                                wc.status, wc.vendor_err);
                        return -1;
                    }
                    /* success – got one completion */
                    break;
                }
                /* n == 0: no CQE yet, back off briefly */
                usleep(100); /* 100us */
            }
            if (n == 0) {
                fprintf(stderr, "no completion within budget\n");
                return -1;
            }
        }
        printf("[70] done.\n");

    printf("[71] RegMR(pd=pd0, mr=mr_54721, addr=bufs[66], length=4096, access=1049295) start.\n");

    /* ibv_reg_mr */
    mr_54721 = ibv_reg_mr(pd0, bufs[66], 4096, 1049295);
    if (!mr_54721) {
        fprintf(stderr, "Failed to register memory region\n");
        return -1;
    }
    
    mrs[mrs_size++] = (PR_MR){
        .id = "mr_54721",
        .addr = (uint64_t)(mr_54721->addr),
        .length = 1024,
        .lkey = mr_54721->lkey};
        
    pr_write_client_update_claimed(CLIENT_UPDATE_PATH, qps, qps_size, mrs, mrs_size, prs, prs_size);
    
    printf("[71] done.\n");

    printf("[72] CreateSRQ(pd=pd0, srq=srq_527, srq_init_obj=IbvSrqInitAttr{attr=IbvSrqAttr{max_wr=1, max_sge=1, srq_limit=0}}) start.\n");

    /* ibv_create_srq */
    
    memset(&srq_init_attr__527, 0, sizeof(srq_init_attr__527));

    memset(&srq_init_attr__527_attr, 0, sizeof(srq_init_attr__527_attr));
    srq_init_attr__527_attr.max_wr = 1;
    srq_init_attr__527_attr.max_sge = 1;
    srq_init_attr__527_attr.srq_limit = 0;
    srq_init_attr__527.attr = srq_init_attr__527_attr;

    srq_527 = ibv_create_srq(pd0, &srq_init_attr__527);
    if (!srq_527) {
        fprintf(stderr, "Failed to create SRQ\n");
        return -1;
    }
    printf("[72] done.\n");

    printf("[73] CreateSRQ(pd=pd_2691, srq=srq_34909, srq_init_obj=IbvSrqInitAttr{attr=IbvSrqAttr{max_wr=1, max_sge=1, srq_limit=0}}) start.\n");

    /* ibv_create_srq */
    
    memset(&srq_init_attr__34909, 0, sizeof(srq_init_attr__34909));

    memset(&srq_init_attr__34909_attr, 0, sizeof(srq_init_attr__34909_attr));
    srq_init_attr__34909_attr.max_wr = 1;
    srq_init_attr__34909_attr.max_sge = 1;
    srq_init_attr__34909_attr.srq_limit = 0;
    srq_init_attr__34909.attr = srq_init_attr__34909_attr;

    srq_34909 = ibv_create_srq(pd_2691, &srq_init_attr__34909);
    if (!srq_34909) {
        fprintf(stderr, "Failed to create SRQ\n");
        return -1;
    }
    printf("[73] done.\n");

    printf("[74] ModifySRQ(srq=srq_37114, attr_var=srq_attr_srq_37114, attr_obj=IbvSrqAttr{max_wr=1, srq_limit=0}, attr_mask=IBV_SRQ_MAX_WR | IBV_SRQ_LIMIT) start.\n");

    memset(&srq_attr_srq_37114, 0, sizeof(srq_attr_srq_37114));
    srq_attr_srq_37114.max_wr = 1;
    srq_attr_srq_37114.srq_limit = 0;

    if (ibv_modify_srq(srq_37114, &srq_attr_srq_37114, IBV_SRQ_MAX_WR | IBV_SRQ_LIMIT) != 0) {
        fprintf(stderr, "ibv_modify_srq failed\n");
        return -1;
    }
    printf("[74] done.\n");

    printf("[75] DeallocPD(pd=pd1) start.\n");

    /* ibv_dealloc_pd */
    if (ibv_dealloc_pd(pd1)) {
        fprintf(stderr, "Failed to deallocate PD \n");
        return -1;
    }
    printf("[75] done.\n");

    printf("[76] DestroyCQ(cq=cq_42368) start.\n");

    /* ibv_destroy_cq */
    if (ibv_destroy_cq(cq_42368)) {
        fprintf(stderr, "Failed to destroy CQ\n");
        return -1;
    }
    printf("[76] done.\n");

    printf("[77] DeregMR(mr=mr_54721) start.\n");

    /* ibv_dereg_mr */
    if (ibv_dereg_mr(mr_54721)) {
        fprintf(stderr, "Failed to deregister MR\n");
        return -1;
    }
    printf("[77] done.\n");

    printf("[78] CreateSRQ(pd=pd0, srq=srq_4458, srq_init_obj=IbvSrqInitAttr{attr=IbvSrqAttr{max_wr=1, max_sge=1, srq_limit=0}}) start.\n");

    /* ibv_create_srq */
    
    memset(&srq_init_attr__4458, 0, sizeof(srq_init_attr__4458));

    memset(&srq_init_attr__4458_attr, 0, sizeof(srq_init_attr__4458_attr));
    srq_init_attr__4458_attr.max_wr = 1;
    srq_init_attr__4458_attr.max_sge = 1;
    srq_init_attr__4458_attr.srq_limit = 0;
    srq_init_attr__4458.attr = srq_init_attr__4458_attr;

    srq_4458 = ibv_create_srq(pd0, &srq_init_attr__4458);
    if (!srq_4458) {
        fprintf(stderr, "Failed to create SRQ\n");
        return -1;
    }
    printf("[78] done.\n");

    printf("[79] CreateCQ(cqe=16, cq_context=NULL, channel=NULL, comp_vector=0, cq=cq_37403) start.\n");

    /* ibv_create_cq */
    cq_37403 = ibv_create_cq(ctx, 16, 
                              NULL, NULL, 
                              0);
    if (!cq_37403) {
        fprintf(stderr, "Failed to create completion queue\n");
        return -1;
    }
    printf("[79] done.\n");

    printf("[80] ModifyCQ(cq=cq_37403, attr_obj=IbvModifyCQAttr{attr_mask=0, moderate=IbvModerateCQ{cq_count=1, cq_period=1}}, attr_var=modify_cq_attr) start.\n");

    memset(&modify_cq_attr, 0, sizeof(modify_cq_attr));
    modify_cq_attr.attr_mask = 0;

    memset(&modify_cq_attr_moderate, 0, sizeof(modify_cq_attr_moderate));
    modify_cq_attr_moderate.cq_count = 1;
    modify_cq_attr_moderate.cq_period = 1;
    modify_cq_attr.moderate = modify_cq_attr_moderate;

    if (ibv_modify_cq(cq_37403, &modify_cq_attr) != 0) {
        fprintf(stderr, "ibv_modify_cq failed\n");
        return -1;
    }
    printf("[80] done.\n");

    printf("[81] ModifyCQ(cq=cq_37403, attr_obj=IbvModifyCQAttr{attr_mask=0, moderate=IbvModerateCQ{cq_count=1, cq_period=1}}, attr_var=modify_cq_attr) start.\n");

    memset(&modify_cq_attr, 0, sizeof(modify_cq_attr));
    modify_cq_attr.attr_mask = 0;

    memset(&modify_cq_attr_moderate, 0, sizeof(modify_cq_attr_moderate));
    modify_cq_attr_moderate.cq_count = 1;
    modify_cq_attr_moderate.cq_period = 1;
    modify_cq_attr.moderate = modify_cq_attr_moderate;

    if (ibv_modify_cq(cq_37403, &modify_cq_attr) != 0) {
        fprintf(stderr, "ibv_modify_cq failed\n");
        return -1;
    }
    printf("[81] done.\n");

    printf("[82] ModifyCQ(cq=cq_59698, attr_obj=IbvModifyCQAttr{attr_mask=0, moderate=IbvModerateCQ{cq_count=1, cq_period=1}}, attr_var=modify_cq_attr) start.\n");

    memset(&modify_cq_attr, 0, sizeof(modify_cq_attr));
    modify_cq_attr.attr_mask = 0;

    memset(&modify_cq_attr_moderate, 0, sizeof(modify_cq_attr_moderate));
    modify_cq_attr_moderate.cq_count = 1;
    modify_cq_attr_moderate.cq_period = 1;
    modify_cq_attr.moderate = modify_cq_attr_moderate;

    if (ibv_modify_cq(cq_59698, &modify_cq_attr) != 0) {
        fprintf(stderr, "ibv_modify_cq failed\n");
        return -1;
    }
    printf("[82] done.\n");

    printf("[83] ModifySRQ(srq=srq_52708, attr_var=srq_attr_srq_52708, attr_obj=IbvSrqAttr{max_wr=1, srq_limit=0}, attr_mask=IBV_SRQ_MAX_WR | IBV_SRQ_LIMIT) start.\n");

    memset(&srq_attr_srq_52708, 0, sizeof(srq_attr_srq_52708));
    srq_attr_srq_52708.max_wr = 1;
    srq_attr_srq_52708.srq_limit = 0;

    if (ibv_modify_srq(srq_52708, &srq_attr_srq_52708, IBV_SRQ_MAX_WR | IBV_SRQ_LIMIT) != 0) {
        fprintf(stderr, "ibv_modify_srq failed\n");
        return -1;
    }
    printf("[83] done.\n");

    printf("[84] ModifySRQ(srq=srq_527, attr_var=srq_attr_srq_527, attr_obj=IbvSrqAttr{max_wr=1, srq_limit=0}, attr_mask=IBV_SRQ_MAX_WR | IBV_SRQ_LIMIT) start.\n");

    memset(&srq_attr_srq_527, 0, sizeof(srq_attr_srq_527));
    srq_attr_srq_527.max_wr = 1;
    srq_attr_srq_527.srq_limit = 0;

    if (ibv_modify_srq(srq_527, &srq_attr_srq_527, IBV_SRQ_MAX_WR | IBV_SRQ_LIMIT) != 0) {
        fprintf(stderr, "ibv_modify_srq failed\n");
        return -1;
    }
    printf("[84] done.\n");

    printf("[85] PollCQ(cq=cq_37403) start.\n");

        /* ibv_poll_cq — self-contained minimal polling */
        {
            struct ibv_wc wc;
            int n = 0;
            int attempts = 100;   /* ~100 * 100us ≈ 10ms */
            while (attempts-- > 0) {
                n = ibv_poll_cq(cq_37403, 1, &wc);
                if (n < 0) {
                    fprintf(stderr, "ibv_poll_cq failed\n");
                    return -1;
                }
                if (n == 1) {
                    if (wc.status != IBV_WC_SUCCESS) {
                        fprintf(stderr, "bad completion: status=0x%x vendor=0x%x\n",
                                wc.status, wc.vendor_err);
                        return -1;
                    }
                    /* success – got one completion */
                    break;
                }
                /* n == 0: no CQE yet, back off briefly */
                usleep(100); /* 100us */
            }
            if (n == 0) {
                fprintf(stderr, "no completion within budget\n");
                return -1;
            }
        }
        printf("[85] done.\n");

    printf("[86] ModifySRQ(srq=srq_56708, attr_var=srq_attr_srq_56708, attr_obj=IbvSrqAttr{max_wr=1, srq_limit=0}, attr_mask=IBV_SRQ_MAX_WR | IBV_SRQ_LIMIT) start.\n");

    memset(&srq_attr_srq_56708, 0, sizeof(srq_attr_srq_56708));
    srq_attr_srq_56708.max_wr = 1;
    srq_attr_srq_56708.srq_limit = 0;

    if (ibv_modify_srq(srq_56708, &srq_attr_srq_56708, IBV_SRQ_MAX_WR | IBV_SRQ_LIMIT) != 0) {
        fprintf(stderr, "ibv_modify_srq failed\n");
        return -1;
    }
    printf("[86] done.\n");

    printf("[87] CreateQP(pd=pd_27245, qp=qp_23942, init_attr_obj=IbvQPInitAttr{send_cq=cq_6779, recv_cq=cq_59698, qp_type=IBV_QPT_RC, cap=IbvQPCap{max_send_wr=1, max_recv_wr=1, max_send_sge=1, max_recv_sge=1}}, remote_qp=srv5) start.\n");

    /* ibv_create_qp */
    
    memset(&attr_init_qp_23942, 0, sizeof(attr_init_qp_23942));
    attr_init_qp_23942.send_cq = cq_6779;
    attr_init_qp_23942.recv_cq = cq_59698;

    memset(&attr_init_qp_23942_cap, 0, sizeof(attr_init_qp_23942_cap));
    attr_init_qp_23942_cap.max_send_wr = 1;
    attr_init_qp_23942_cap.max_recv_wr = 1;
    attr_init_qp_23942_cap.max_send_sge = 1;
    attr_init_qp_23942_cap.max_recv_sge = 1;
    attr_init_qp_23942.cap = attr_init_qp_23942_cap;
    attr_init_qp_23942.qp_type = IBV_QPT_RC;

    qp_23942 = ibv_create_qp(pd_27245, &attr_init_qp_23942);
    if (!qp_23942) {
        fprintf(stderr, "Failed to create QP\n");
        return -1;
    }
    
    qps[qps_size++] = (PR_QP){
        .id = "qp_23942",
        .qpn = qp_23942->qp_num,
        .psn = 0,
        .port = 1,
        .lid = 0,
        .gid = "" // will set below
    };
    
    snprintf(qps[qps_size-1].gid, sizeof(qps[qps_size-1].gid),
                 "%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x",
                 gid.raw[0], gid.raw[1], gid.raw[2], gid.raw[3], gid.raw[4], gid.raw[5], gid.raw[6], gid.raw[7], gid.raw[8], gid.raw[9], gid.raw[10], gid.raw[11], gid.raw[12], gid.raw[13], gid.raw[14], gid.raw[15]);
                 
    prs[prs_size++] = (PR_Pair){
        .id = "pair-qp_23942-srv5",
        .cli_id = "qp_23942",
        .srv_id = "srv5"
    };
    
    pr_write_client_update_claimed(CLIENT_UPDATE_PATH, qps, qps_size, mrs, mrs_size, prs, prs_size);
    printf("[87] done.\n");

    printf("[88] DeallocPD(pd=pd_1893) start.\n");

    /* ibv_dealloc_pd */
    if (ibv_dealloc_pd(pd_1893)) {
        fprintf(stderr, "Failed to deallocate PD \n");
        return -1;
    }
    printf("[88] done.\n");

    printf("[89] RegMR(pd=pd0, mr=mr_46984, addr=bufs[21], length=4096, access=IBV_ACCESS_LOCAL_WRITE) start.\n");

    /* ibv_reg_mr */
    mr_46984 = ibv_reg_mr(pd0, bufs[21], 4096, IBV_ACCESS_LOCAL_WRITE);
    if (!mr_46984) {
        fprintf(stderr, "Failed to register memory region\n");
        return -1;
    }
    
    mrs[mrs_size++] = (PR_MR){
        .id = "mr_46984",
        .addr = (uint64_t)(mr_46984->addr),
        .length = 1024,
        .lkey = mr_46984->lkey};
        
    pr_write_client_update_claimed(CLIENT_UPDATE_PATH, qps, qps_size, mrs, mrs_size, prs, prs_size);
    
    printf("[89] done.\n");

    printf("[90] RegMR(pd=pd_27245, mr=mr_48464, addr=bufs[86], length=4096, access=IBV_ACCESS_LOCAL_WRITE) start.\n");

    /* ibv_reg_mr */
    mr_48464 = ibv_reg_mr(pd_27245, bufs[86], 4096, IBV_ACCESS_LOCAL_WRITE);
    if (!mr_48464) {
        fprintf(stderr, "Failed to register memory region\n");
        return -1;
    }
    
    mrs[mrs_size++] = (PR_MR){
        .id = "mr_48464",
        .addr = (uint64_t)(mr_48464->addr),
        .length = 1024,
        .lkey = mr_48464->lkey};
        
    pr_write_client_update_claimed(CLIENT_UPDATE_PATH, qps, qps_size, mrs, mrs_size, prs, prs_size);
    
    printf("[90] done.\n");

    printf("[91] CreateCQ(cqe=16, cq_context=NULL, channel=NULL, comp_vector=0, cq=cq_57283) start.\n");

    /* ibv_create_cq */
    cq_57283 = ibv_create_cq(ctx, 16, 
                              NULL, NULL, 
                              0);
    if (!cq_57283) {
        fprintf(stderr, "Failed to create completion queue\n");
        return -1;
    }
    printf("[91] done.\n");

    printf("[92] ModifySRQ(srq=srq_32963, attr_var=srq_attr_srq_32963, attr_obj=IbvSrqAttr{max_wr=1, srq_limit=0}, attr_mask=IBV_SRQ_MAX_WR | IBV_SRQ_LIMIT) start.\n");

    memset(&srq_attr_srq_32963, 0, sizeof(srq_attr_srq_32963));
    srq_attr_srq_32963.max_wr = 1;
    srq_attr_srq_32963.srq_limit = 0;

    if (ibv_modify_srq(srq_32963, &srq_attr_srq_32963, IBV_SRQ_MAX_WR | IBV_SRQ_LIMIT) != 0) {
        fprintf(stderr, "ibv_modify_srq failed\n");
        return -1;
    }
    printf("[92] done.\n");

    printf("[93] DestroyQP(qp=qp_23942) start.\n");

    /* ibv_destroy_qp */
    if (ibv_destroy_qp(qp_23942)) {
        fprintf(stderr, "Failed to destroy QP\n");
        return -1;
    }
    printf("[93] done.\n");

    printf("[94] RegMR(pd=pd_36775, mr=mr_35879, addr=bufs[57], length=4096, access=IBV_ACCESS_LOCAL_WRITE) start.\n");

    /* ibv_reg_mr */
    mr_35879 = ibv_reg_mr(pd_36775, bufs[57], 4096, IBV_ACCESS_LOCAL_WRITE);
    if (!mr_35879) {
        fprintf(stderr, "Failed to register memory region\n");
        return -1;
    }
    
    mrs[mrs_size++] = (PR_MR){
        .id = "mr_35879",
        .addr = (uint64_t)(mr_35879->addr),
        .length = 1024,
        .lkey = mr_35879->lkey};
        
    pr_write_client_update_claimed(CLIENT_UPDATE_PATH, qps, qps_size, mrs, mrs_size, prs, prs_size);
    
    printf("[94] done.\n");

    printf("[95] DeallocPD(pd=pd_30852) start.\n");

    /* ibv_dealloc_pd */
    if (ibv_dealloc_pd(pd_30852)) {
        fprintf(stderr, "Failed to deallocate PD \n");
        return -1;
    }
    printf("[95] done.\n");

    printf("[96] AllocPD(pd=pd_61783) start.\n");

    /* ibv_alloc_pd */
    pd_61783 = ibv_alloc_pd(ctx);
    if (!pd_61783) {
        fprintf(stderr, "Failed to allocate protection domain\n");
        return -1;
    }
    printf("[96] done.\n");

    printf("[97] CreateCQ(cqe=16, cq_context=NULL, channel=NULL, comp_vector=0, cq=cq_2877) start.\n");

    /* ibv_create_cq */
    cq_2877 = ibv_create_cq(ctx, 16, 
                              NULL, NULL, 
                              0);
    if (!cq_2877) {
        fprintf(stderr, "Failed to create completion queue\n");
        return -1;
    }
    printf("[97] done.\n");

    printf("[98] PollCQ(cq=cq_6779) start.\n");

        /* ibv_poll_cq — self-contained minimal polling */
        {
            struct ibv_wc wc;
            int n = 0;
            int attempts = 100;   /* ~100 * 100us ≈ 10ms */
            while (attempts-- > 0) {
                n = ibv_poll_cq(cq_6779, 1, &wc);
                if (n < 0) {
                    fprintf(stderr, "ibv_poll_cq failed\n");
                    return -1;
                }
                if (n == 1) {
                    if (wc.status != IBV_WC_SUCCESS) {
                        fprintf(stderr, "bad completion: status=0x%x vendor=0x%x\n",
                                wc.status, wc.vendor_err);
                        return -1;
                    }
                    /* success – got one completion */
                    break;
                }
                /* n == 0: no CQE yet, back off briefly */
                usleep(100); /* 100us */
            }
            if (n == 0) {
                fprintf(stderr, "no completion within budget\n");
                return -1;
            }
        }
        printf("[98] done.\n");

    printf("[99] CreateCQ(cqe=16, cq_context=NULL, channel=NULL, comp_vector=0, cq=cq_55148) start.\n");

    /* ibv_create_cq */
    cq_55148 = ibv_create_cq(ctx, 16, 
                              NULL, NULL, 
                              0);
    if (!cq_55148) {
        fprintf(stderr, "Failed to create completion queue\n");
        return -1;
    }
    printf("[99] done.\n");

    printf("[100] DestroyCQ(cq=cq_43136) start.\n");

    /* ibv_destroy_cq */
    if (ibv_destroy_cq(cq_43136)) {
        fprintf(stderr, "Failed to destroy CQ\n");
        return -1;
    }
    printf("[100] done.\n");

    printf("[101] RegMR(pd=pd_22571, mr=mr_19821, addr=bufs[44], length=4096, access=IBV_ACCESS_LOCAL_WRITE) start.\n");

    /* ibv_reg_mr */
    mr_19821 = ibv_reg_mr(pd_22571, bufs[44], 4096, IBV_ACCESS_LOCAL_WRITE);
    if (!mr_19821) {
        fprintf(stderr, "Failed to register memory region\n");
        return -1;
    }
    
    mrs[mrs_size++] = (PR_MR){
        .id = "mr_19821",
        .addr = (uint64_t)(mr_19821->addr),
        .length = 1024,
        .lkey = mr_19821->lkey};
        
    pr_write_client_update_claimed(CLIENT_UPDATE_PATH, qps, qps_size, mrs, mrs_size, prs, prs_size);
    
    printf("[101] done.\n");

    printf("[102] CreateSRQ(pd=pd0, srq=srq0, srq_init_obj=IbvSrqInitAttr{attr=IbvSrqAttr{max_wr=0, srq_limit=0}}) start.\n");

    /* ibv_create_srq */
    
    memset(&srq_init_attr_0, 0, sizeof(srq_init_attr_0));

    memset(&srq_init_attr_0_attr, 0, sizeof(srq_init_attr_0_attr));
    srq_init_attr_0_attr.max_wr = 0;
    srq_init_attr_0_attr.srq_limit = 0;
    srq_init_attr_0.attr = srq_init_attr_0_attr;

    srq0 = ibv_create_srq(pd0, &srq_init_attr_0);
    if (!srq0) {
        fprintf(stderr, "Failed to create SRQ\n");
        return -1;
    }
    printf("[102] done.\n");

    printf("[103] ModifySRQ(srq=srq_40224, attr_var=srq_attr_srq_40224, attr_obj=IbvSrqAttr{max_wr=1, srq_limit=0}, attr_mask=IBV_SRQ_MAX_WR | IBV_SRQ_LIMIT) start.\n");

    memset(&srq_attr_srq_40224, 0, sizeof(srq_attr_srq_40224));
    srq_attr_srq_40224.max_wr = 1;
    srq_attr_srq_40224.srq_limit = 0;

    if (ibv_modify_srq(srq_40224, &srq_attr_srq_40224, IBV_SRQ_MAX_WR | IBV_SRQ_LIMIT) != 0) {
        fprintf(stderr, "ibv_modify_srq failed\n");
        return -1;
    }
    printf("[103] done.\n");

    printf("[104] ModifySRQ(srq=srq_40224, attr_var=srq_attr_srq_40224, attr_obj=IbvSrqAttr{max_wr=1, srq_limit=0}, attr_mask=IBV_SRQ_MAX_WR | IBV_SRQ_LIMIT) start.\n");

    memset(&srq_attr_srq_40224, 0, sizeof(srq_attr_srq_40224));
    srq_attr_srq_40224.max_wr = 1;
    srq_attr_srq_40224.srq_limit = 0;

    if (ibv_modify_srq(srq_40224, &srq_attr_srq_40224, IBV_SRQ_MAX_WR | IBV_SRQ_LIMIT) != 0) {
        fprintf(stderr, "ibv_modify_srq failed\n");
        return -1;
    }
    printf("[104] done.\n");

    printf("[105] RegMR(pd=pd_27245, mr=mr_3172, addr=bufs[33], length=4096, access=IBV_ACCESS_LOCAL_WRITE) start.\n");

    /* ibv_reg_mr */
    mr_3172 = ibv_reg_mr(pd_27245, bufs[33], 4096, IBV_ACCESS_LOCAL_WRITE);
    if (!mr_3172) {
        fprintf(stderr, "Failed to register memory region\n");
        return -1;
    }
    
    mrs[mrs_size++] = (PR_MR){
        .id = "mr_3172",
        .addr = (uint64_t)(mr_3172->addr),
        .length = 1024,
        .lkey = mr_3172->lkey};
        
    pr_write_client_update_claimed(CLIENT_UPDATE_PATH, qps, qps_size, mrs, mrs_size, prs, prs_size);
    
    printf("[105] done.\n");

    printf("[106] CreateQP(pd=pd0, qp=qp_15186, init_attr_obj=IbvQPInitAttr{send_cq=cq_6779, recv_cq=cq_57283, qp_type=IBV_QPT_RC, cap=IbvQPCap{max_send_wr=1, max_recv_wr=1, max_send_sge=1, max_recv_sge=1}}, remote_qp=srv82) start.\n");

    /* ibv_create_qp */
    
    memset(&attr_init_qp_15186, 0, sizeof(attr_init_qp_15186));
    attr_init_qp_15186.send_cq = cq_6779;
    attr_init_qp_15186.recv_cq = cq_57283;

    memset(&attr_init_qp_15186_cap, 0, sizeof(attr_init_qp_15186_cap));
    attr_init_qp_15186_cap.max_send_wr = 1;
    attr_init_qp_15186_cap.max_recv_wr = 1;
    attr_init_qp_15186_cap.max_send_sge = 1;
    attr_init_qp_15186_cap.max_recv_sge = 1;
    attr_init_qp_15186.cap = attr_init_qp_15186_cap;
    attr_init_qp_15186.qp_type = IBV_QPT_RC;

    qp_15186 = ibv_create_qp(pd0, &attr_init_qp_15186);
    if (!qp_15186) {
        fprintf(stderr, "Failed to create QP\n");
        return -1;
    }
    
    qps[qps_size++] = (PR_QP){
        .id = "qp_15186",
        .qpn = qp_15186->qp_num,
        .psn = 0,
        .port = 1,
        .lid = 0,
        .gid = "" // will set below
    };
    
    snprintf(qps[qps_size-1].gid, sizeof(qps[qps_size-1].gid),
                 "%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x",
                 gid.raw[0], gid.raw[1], gid.raw[2], gid.raw[3], gid.raw[4], gid.raw[5], gid.raw[6], gid.raw[7], gid.raw[8], gid.raw[9], gid.raw[10], gid.raw[11], gid.raw[12], gid.raw[13], gid.raw[14], gid.raw[15]);
                 
    prs[prs_size++] = (PR_Pair){
        .id = "pair-qp_15186-srv82",
        .cli_id = "qp_15186",
        .srv_id = "srv82"
    };
    
    pr_write_client_update_claimed(CLIENT_UPDATE_PATH, qps, qps_size, mrs, mrs_size, prs, prs_size);
    printf("[106] done.\n");

    printf("[107] PollCQ(cq=cq_57283) start.\n");

        /* ibv_poll_cq — self-contained minimal polling */
        {
            struct ibv_wc wc;
            int n = 0;
            int attempts = 100;   /* ~100 * 100us ≈ 10ms */
            while (attempts-- > 0) {
                n = ibv_poll_cq(cq_57283, 1, &wc);
                if (n < 0) {
                    fprintf(stderr, "ibv_poll_cq failed\n");
                    return -1;
                }
                if (n == 1) {
                    if (wc.status != IBV_WC_SUCCESS) {
                        fprintf(stderr, "bad completion: status=0x%x vendor=0x%x\n",
                                wc.status, wc.vendor_err);
                        return -1;
                    }
                    /* success – got one completion */
                    break;
                }
                /* n == 0: no CQE yet, back off briefly */
                usleep(100); /* 100us */
            }
            if (n == 0) {
                fprintf(stderr, "no completion within budget\n");
                return -1;
            }
        }
        printf("[107] done.\n");

    printf("[108] AllocPD(pd=pd_23514) start.\n");

    /* ibv_alloc_pd */
    pd_23514 = ibv_alloc_pd(ctx);
    if (!pd_23514) {
        fprintf(stderr, "Failed to allocate protection domain\n");
        return -1;
    }
    printf("[108] done.\n");

    printf("[109] CreateCQ(cqe=16, cq_context=NULL, channel=NULL, comp_vector=0, cq=cq_43544) start.\n");

    /* ibv_create_cq */
    cq_43544 = ibv_create_cq(ctx, 16, 
                              NULL, NULL, 
                              0);
    if (!cq_43544) {
        fprintf(stderr, "Failed to create completion queue\n");
        return -1;
    }
    printf("[109] done.\n");

    printf("[110] ModifyCQ(cq=cq_57283, attr_obj=IbvModifyCQAttr{attr_mask=0, moderate=IbvModerateCQ{cq_count=1, cq_period=1}}, attr_var=modify_cq_attr) start.\n");

    memset(&modify_cq_attr, 0, sizeof(modify_cq_attr));
    modify_cq_attr.attr_mask = 0;

    memset(&modify_cq_attr_moderate, 0, sizeof(modify_cq_attr_moderate));
    modify_cq_attr_moderate.cq_count = 1;
    modify_cq_attr_moderate.cq_period = 1;
    modify_cq_attr.moderate = modify_cq_attr_moderate;

    if (ibv_modify_cq(cq_57283, &modify_cq_attr) != 0) {
        fprintf(stderr, "ibv_modify_cq failed\n");
        return -1;
    }
    printf("[110] done.\n");

    printf("[111] DestroyQP(qp=qp_15186) start.\n");

    /* ibv_destroy_qp */
    if (ibv_destroy_qp(qp_15186)) {
        fprintf(stderr, "Failed to destroy QP\n");
        return -1;
    }
    printf("[111] done.\n");

    printf("[112] CreateCQ(cqe=16, cq_context=NULL, channel=NULL, comp_vector=0, cq=cq_46499) start.\n");

    /* ibv_create_cq */
    cq_46499 = ibv_create_cq(ctx, 16, 
                              NULL, NULL, 
                              0);
    if (!cq_46499) {
        fprintf(stderr, "Failed to create completion queue\n");
        return -1;
    }
    printf("[112] done.\n");

    printf("[113] RegMR(pd=pd_23514, mr=mr_26461, addr=bufs[98], length=4096, access=IBV_ACCESS_LOCAL_WRITE) start.\n");

    /* ibv_reg_mr */
    mr_26461 = ibv_reg_mr(pd_23514, bufs[98], 4096, IBV_ACCESS_LOCAL_WRITE);
    if (!mr_26461) {
        fprintf(stderr, "Failed to register memory region\n");
        return -1;
    }
    
    mrs[mrs_size++] = (PR_MR){
        .id = "mr_26461",
        .addr = (uint64_t)(mr_26461->addr),
        .length = 1024,
        .lkey = mr_26461->lkey};
        
    pr_write_client_update_claimed(CLIENT_UPDATE_PATH, qps, qps_size, mrs, mrs_size, prs, prs_size);
    
    printf("[113] done.\n");



    // --- Optional CQ polling / cleanup (generated or static) ---
    /* optional CQ polling & cleanup */

    return 0;
}