// AUTOGEN: RDMA client (pairs + runtime) — generated by your fuzzer
// Toolchain: g++ -O2 -std=c++17 pair_runtime.cpp runtime_resolver.c cJSON.c -libverbs -pthread -o rdma_client_autogen

#include <infiniband/verbs.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <thread>
#include <vector>
#include <string>
#include <algorithm>

#include "pair_runtime.h"

using std::string;
using std::vector;

static void die(const char *m)
{
    perror(m);
    exit(1);
}

static int to_init(ibv_qp *qp, uint8_t port)
{
    ibv_qp_attr a;
    memset(&a, 0, sizeof(a));
    a.qp_state = IBV_QPS_INIT;
    a.pkey_index = 0;
    a.port_num = port;
    a.qp_access_flags = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE;
    int flags = IBV_QP_STATE | IBV_QP_PKEY_INDEX | IBV_QP_PORT | IBV_QP_ACCESS_FLAGS;
    return ibv_modify_qp(qp, &a, flags);
}

// --------- User-configurable knobs (autofilled by generator) ----------
static const int IB_PORT = 1;
static const int MSG_SIZE = 1024;
static const char *BUNDLE_ENV = "RDMA_FUZZ_RUNTIME";
static const char *CLIENT_UPDATE_PATH = "client_update.json";
static const char *PAIR_ID = "pair-cli0-srv0";
static const char *CLI_ID = "cli0";
static const char *SRV_ID = "srv0";

// --------- Prolog helper (optional; you can keep minimal) -------------

// ---------------------- main ----------------------
int main(int argc, char **argv)
{
    pr_init(BUNDLE_ENV);

    // --- Open device / PD / CQ ---
    int num = 0;
    ibv_device **dev_list = ibv_get_device_list(&num);
    if (!dev_list || num <= 0)
        die("ibv_get_device_list");
    ibv_context *ctx = ibv_open_device(dev_list[0]);
    if (!ctx)
        die("ibv_open_device");
    ibv_pd *pd = ibv_alloc_pd(ctx);
    if (!pd)
        die("ibv_alloc_pd");
    ibv_cq *cq = ibv_create_cq(ctx, 1024, nullptr, nullptr, 0);
    if (!cq)
        die("ibv_create_cq");

    // --- Local buffers / MRs / QPs (generated) ---
    /* setup generated by verbs (alloc/reg/create) moved here if你把这些也用 generate_c 产出 */

    // --- Prepare PR_* for CLAIMED ---
    PR_QP qps[1];
    PR_MR mrs[1];
    PR_Pair prs[1];

    // Fill PR_QP
    qps[0] = (PR_QP){
        .id = "cli0",
        .qpn = qp0->qp_num,
        .psn = 0,
        .port = 1,
        .lid = 0,
        .gid = "" // will set below
    };
    pr_qp_set_gid_str(&qps[0], "00:...:00");

    // Fill PR_MR
    mrs[0] = (PR_MR){
        .id = "sbuf_cli0",
        .addr = (uint64_t)(mr0->addr),
        .length = 1024,
        .lkey = mr0->lkey};

    // Fill PR_Pair
    prs[0] = (PR_Pair){
        .id = "pair-cli0-srv0",
        .cli_id = "cli0",
        .srv_id = "srv0"};

    // --- CLAIMED ---
    pr_write_client_update_claimed(CLIENT_UPDATE_PATH, qps, 1, mrs, 1, prs, 1);

    // --- Optional early verbs (don’t need remote params; e.g., PostRecv) ---

    // --- WAIT/RESOLVE gate (inserted only if needed) ---
    if (!pr_wait_pair_state(BUNDLE_ENV, PAIR_ID, "READY", 15000))
    {
        fprintf(stderr, "timeout waiting for READY on %s\n", PAIR_ID);
        return -1;
    }

    // Resolve remote QP / MR (by-id). Use whatever you actually need later.
    uint32_t rqpn = 0, rpsn = 0;
    uint16_t rlid = 0;
    uint8_t rgid[16] = {0};
    uint8_t rport = IB_PORT;
    pr_resolve_remote_qp(SRV_ID, &rqpn, &rpsn, &rlid, rgid, &rport);

    uint64_t raddr = 0;
    uint32_t rrkey = 0, rlen = 0;
    pr_resolve_remote_mr("rbuf_srv0", &raddr, &rrkey, &rlen);

    // READY (announce)
    pr_write_client_update_ready(CLIENT_UPDATE_PATH, qps, 1, mrs, 1, prs, 1);

    // --- Main verbs body (generated) ---

    /* ibv_alloc_pd */
    pd0 = ibv_alloc_pd(ctx);
    if (!pd0)
    {
        fprintf(stderr, "Failed to allocate protection domain\n");
        return -1;
    }

    /* ibv_create_cq */
    cq0 = ibv_create_cq(ctx, 128,
                        NULL, NULL,
                        0);
    if (!cq0)
    {
        fprintf(stderr, "Failed to create completion queue\n");
        return -1;
    }

    /* ibv_create_qp */

    memset(&attr_init_qp0, 0, sizeof(attr_init_qp0));
    attr_init_qp0.send_cq = cq0;
    attr_init_qp0.recv_cq = cq0;

    memset(&attr_init_qp0_cap, 0, sizeof(attr_init_qp0_cap));
    attr_init_qp0_cap.max_send_wr = 1;
    attr_init_qp0_cap.max_recv_wr = 1;
    attr_init_qp0_cap.max_send_sge = 1;
    attr_init_qp0_cap.max_recv_sge = 1;
    attr_init_qp0.cap = attr_init_qp0_cap;

    qp0 = ibv_create_qp(pd0, &attr_init_qp0);
    if (!qp0)
    {
        fprintf(stderr, "Failed to create QP\n");
        return -1;
    }

    memset(&qp_attr_qp0, 0, sizeof(qp_attr_qp0));

    memset(&qp_attr_qp0, 0, sizeof(qp_attr_qp0));
    qp_attr_qp0.qp_state = IBV_QPS_RTR;

    ibv_modify_qp(qp0, &qp_attr_qp0, IBV_QP_STATE);

    memset(&qp_attr_qp0, 0, sizeof(qp_attr_qp0));

    memset(&qp_attr_qp0, 0, sizeof(qp_attr_qp0));
    qp_attr_qp0.qp_state = IBV_QPS_RTS;

    ibv_modify_qp(qp0, &qp_attr_qp0, IBV_QP_STATE);

    /* ibv_post_send */

    memset(&wr_qp0, 0, sizeof(wr_qp0));
    wr_qp0.wr_id = 6055030728835377738;

    memset(&wr_qp0_sge_0, 0, sizeof(wr_qp0_sge_0));
    wr_qp0_sge_0.addr = rr_u64_by_id("local.MR", "12654594126800", "addr");
    wr_qp0_sge_0.length = 1;
    wr_qp0_sge_0.lkey = rr_u32_by_id("local.MR", "3637021649", "lkey");
    wr_qp0.sg_list = &wr_qp0_sge_0;
    wr_qp0.num_sge = 1;
    wr_qp0.opcode = IBV_WR_LOCAL_INV;
    wr_qp0.send_flags = 24196;

    if (ibv_post_send(qp0, &wr_qp0, &bad_wr_qp0) != 0)
    {
        fprintf(stderr, "Failed to post send work request\n");
        return -1;
    }

    // --- Optional CQ polling / cleanup (generated or static) ---
    /* optional CQ polling & cleanup */

    return 0;
}