// AUTOGEN: RDMA client (pairs + runtime) — generated by your fuzzer
// Toolchain: g++ -O2 -std=c++17 pair_runtime.cpp runtime_resolver.c -lcjson -libverbs -pthread -o rdma_client_autogen

#include <infiniband/verbs.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <thread>
#include <vector>
#include <string>
#include <algorithm>

#include "pair_runtime.h"
#include "runtime_resolver.h"

using std::string;
using std::vector;

static void die(const char* m){ perror(m); exit(1); }

// --------- User-configurable knobs (autofilled by generator) ----------
static const int IB_PORT = 1;
static const int MSG_SIZE = 1024;
static const char* BUNDLE_ENV = "RDMA_FUZZ_RUNTIME";
static const char* CLIENT_UPDATE_PATH = "client_update.json";

// --------- Prolog helper (optional; you can keep minimal) -------------
char bufs[1024][1024];
struct ibv_device ** dev_list;
struct ibv_context * ctx;
struct ibv_device_attr dev_attr;
struct ibv_port_attr port_attr;
union ibv_gid gid;
struct ibv_pd * pd0 = NULL;
struct ibv_cq * cq0 = NULL;
struct ibv_mr * mr0 = NULL;
struct ibv_qp * qp0 = NULL;
uint32_t rqpn_qp0;
uint32_t rlid_qp0;
uint32_t rport_qp0;
const char* rgid_qp0;
struct ibv_qp_init_attr attr_init_qp0;
struct ibv_qp_cap attr_init_qp0_cap;
struct ibv_qp_attr qp_attr_qp0;
struct ibv_ah_attr qp_attr_qp0_ah;
struct ibv_global_route qp_attr_qp0_ah_grh;
struct ibv_send_wr wr_qp0;
struct ibv_sge wr_qp0_sge_0;
struct ibv_send_wr * bad_wr_qp0 = NULL;

// --- Prepare PR_* for CLAIMED ---
PR_QP  qps[1000];
PR_MR  mrs[1000];
PR_Pair prs[1000];
int  qps_size;
int  mrs_size;
int  prs_size;

// ---------------------- main ----------------------
int main(int argc, char** argv){
    pr_init(BUNDLE_ENV);

    // --- Local buffers / MRs / QPs (generated) ---
    

    // --- Optional early verbs (don’t need remote params; e.g., PostRecv) ---
    

    // --- Main verbs body (generated) ---
    
    /* ibv_get_device_list */
    dev_list = ibv_get_device_list(NULL);
    if (!dev_list) {
        fprintf(stderr, "Failed to get device list: %s\n", strerror(errno));
        return -1;
    }

    /* ibv_open_device */
    ctx = ibv_open_device(dev_list[0]);
    if (!ctx) {
        fprintf(stderr, "Failed to open device\n");
        return -1;
    }

    /* ibv_free_device_list */
    ibv_free_device_list(dev_list);

    /* ibv_query_device */
    if (ibv_query_device(ctx, &dev_attr)) {
        fprintf(stderr, "Failed to query device attributes\n");
        return -1;
    }

    /* ibv_query_port */
    if (ibv_query_port(ctx, 1, &port_attr)) {
        fprintf(stderr, "Failed to query port attributes\n");
        return -1;
    }

    /* ibv_query_gid */
    if (ibv_query_gid(ctx, 1, 0, &gid)) {
        fprintf(stderr, "Failed to query GID\n");
        return -1;
    }

    /* ibv_alloc_pd */
    pd0 = ibv_alloc_pd(ctx);
    if (!pd0) {
        fprintf(stderr, "Failed to allocate protection domain\n");
        return -1;
    }

    /* ibv_create_cq */
    cq0 = ibv_create_cq(ctx, 32, 
                              NULL, NULL, 
                              0);
    if (!cq0) {
        fprintf(stderr, "Failed to create completion queue\n");
        return -1;
    }

    /* ibv_reg_mr */
    mr0 = ibv_reg_mr(pd0, bufs[0], 1024, IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE);
    if (!mr0) {
        fprintf(stderr, "Failed to register memory region\n");
        return -1;
    }

    

    // CLAIM MR mr0
    mrs[mrs_size++] = (PR_MR){ .id="mr0", .addr=(uint64_t)(mr0->addr), .length=1024, .lkey=mr0->lkey };
    pr_write_client_update_claimed(CLIENT_UPDATE_PATH, qps, qps_size, mrs, mrs_size, prs, prs_size);

    /* ibv_create_qp */
    
    memset(&attr_init_qp0, 0, sizeof(attr_init_qp0));
    attr_init_qp0.send_cq = cq0;
    attr_init_qp0.recv_cq = cq0;

    memset(&attr_init_qp0_cap, 0, sizeof(attr_init_qp0_cap));
    attr_init_qp0_cap.max_send_wr = 1;
    attr_init_qp0_cap.max_recv_wr = 1;
    attr_init_qp0_cap.max_send_sge = 1;
    attr_init_qp0_cap.max_recv_sge = 1;
    attr_init_qp0.cap = attr_init_qp0_cap;
    attr_init_qp0.qp_type = IBV_QPT_RC;
    attr_init_qp0.sq_sig_all = 1;

    qp0 = ibv_create_qp(pd0, &attr_init_qp0);
    if (!qp0) {
        fprintf(stderr, "Failed to create QP\n");
        return -1;
    }

    // CLAIM QP qp0
    qps[qps_size++] = (PR_QP){ .id="qp0", .qpn=qp0->qp_num, .psn=0, .port=1, .lid=0, .gid="" };
    pr_gid_to_str(gid.raw, qps[qps_size-1].gid, PR_GID_STRLEN);
    pr_write_client_update_claimed(CLIENT_UPDATE_PATH, qps, qps_size, mrs, mrs_size, prs, prs_size);
    memset(&qp_attr_qp0,0,sizeof(qp_attr_qp0));
    qp_attr_qp0.qp_state = IBV_QPS_INIT;
    qp_attr_qp0.qp_access_flags = IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE | IBV_ACCESS_LOCAL_WRITE;
    qp_attr_qp0.pkey_index = 0;
    qp_attr_qp0.port_num = 1;

    // WAIT & RESOLVE for pair-qp0-srv0
    if (!pr_wait_pair_state(BUNDLE_ENV, "pair-qp0-srv0", "BOTH_RTS", 15000)) {
        fprintf(stderr, "wait gate failed\n"); return -1;
    }
    rqpn_qp0  = rr_u32_by_id("remote.QP", "srv0", "qpn");
    rlid_qp0  = rr_u32_by_id("remote.QP", "srv0", "lid");
    rport_qp0 = rr_u32_by_id("remote.QP", "srv0", "port");
    rgid_qp0  = rr_str_by_id("remote.QP", "srv0", "gid");
    pr_write_client_update_ready(CLIENT_UPDATE_PATH, qps, qps_size, mrs, mrs_size, prs, prs_size);
    memset(&qp_attr_qp0,0,sizeof(qp_attr_qp0));
    qp_attr_qp0.qp_state = IBV_QPS_RTR;
    qp_attr_qp0.path_mtu = IBV_MTU_1024;
    qp_attr_qp0.rq_psn = 0;
    qp_attr_qp0.dest_qp_num = rr_u32_by_id("remote.QP", "", "qpn");

    memset(&qp_attr_qp0_ah, 0, sizeof(qp_attr_qp0_ah));

    memset(&qp_attr_qp0_ah_grh, 0, sizeof(qp_attr_qp0_ah_grh));
    pr_parse_gid(rr_str_by_id("remote.QP", "", "gid"), qp_attr_qp0_ah_grh.dgid.raw);
    qp_attr_qp0_ah_grh.flow_label = 0;
    qp_attr_qp0_ah_grh.sgid_index = 1;
    qp_attr_qp0_ah_grh.hop_limit = 1;
    qp_attr_qp0_ah_grh.traffic_class = 0;
    qp_attr_qp0_ah.grh = qp_attr_qp0_ah_grh;
    qp_attr_qp0_ah.dlid = rr_u32_by_id("remote.QP", "", "lid");
    qp_attr_qp0_ah.sl = 0;
    qp_attr_qp0_ah.src_path_bits = 0;
    qp_attr_qp0_ah.is_global = 1;
    qp_attr_qp0_ah.port_num = rr_u32_by_id("remote.QP", "", "port_num");
    qp_attr_qp0.ah_attr = qp_attr_qp0_ah;
    qp_attr_qp0.max_dest_rd_atomic = 1;
    qp_attr_qp0.min_rnr_timer = 12;

    qp_attr_qp0.dest_qp_num = rqpn_qp0;
    pr_parse_gid(rgid_qp0, qp_attr_qp0.ah_attr.grh.dgid.raw);
    qp_attr_qp0.ah_attr.dlid     = rlid_qp0;
    qp_attr_qp0.ah_attr.port_num = rport_qp0;
    qp_attr_qp0.ah_attr.is_global = 1;
    if (ibv_modify_qp(qp0, &qp_attr_qp0, IBV_QP_STATE | IBV_QP_AV | IBV_QP_PATH_MTU | IBV_QP_DEST_QPN | IBV_QP_RQ_PSN | IBV_QP_MAX_DEST_RD_ATOMIC | IBV_QP_MIN_RNR_TIMER)) {
        fprintf(stderr,"ibv_modify_qp failed\n"); return -1;
    }
            memset(&qp_attr_qp0,0,sizeof(qp_attr_qp0));
    qp_attr_qp0.qp_state = IBV_QPS_RTS;
    qp_attr_qp0.sq_psn = 0;
    qp_attr_qp0.max_rd_atomic = 1;
    qp_attr_qp0.timeout = 14;
    qp_attr_qp0.retry_cnt = 7;
    qp_attr_qp0.rnr_retry = 7;

    memset(&wr_qp0, 0, sizeof(wr_qp0));

    memset(&wr_qp0, 0, sizeof(wr_qp0));
    wr_qp0.wr_id = 1;

    memset(&wr_qp0_sge_0, 0, sizeof(wr_qp0_sge_0));
    wr_qp0_sge_0.addr = rr_u64_by_id("local.MR", "mr0", "addr");
    wr_qp0_sge_0.length = MSG_SIZE;
    wr_qp0_sge_0.lkey = rr_u32_by_id("local.MR", "mr0", "lkey");
    wr_qp0.sg_list = &wr_qp0_sge_0;
    wr_qp0.num_sge = 1;
    wr_qp0.opcode = IBV_WR_SEND;
    wr_qp0.send_flags = IBV_SEND_SIGNALED;

            // overwrite SGE with local MR
            wr_qp0_sge_0.addr = laddr_None;
            wr_qp0_sge_0.lkey = lkey_None;
        
        struct ibv_send_wr* bad_wr_qp0 = NULL;
        if (ibv_post_send(qp0, &wr_qp0, &bad_wr_qp0)) {
            fprintf(stderr, "ibv_post_send failed\n"); return -1;
        }
    

    // --- Optional CQ polling / cleanup (generated or static) ---
    /* optional CQ polling & cleanup */

    return 0;
}