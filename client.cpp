// AUTOGEN: RDMA client (pairs + runtime) — generated by your fuzzer
// Toolchain: g++ -O2 -std=c++17 pair_runtime.cpp runtime_resolver.c -lcjson -libverbs -pthread -o rdma_client_autogen

#include <infiniband/verbs.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <thread>
#include <vector>
#include <string>
#include <algorithm>
#include <unistd.h>

#include "pair_runtime.h"
#include "runtime_resolver.h"

using std::string;
using std::vector;

static void die(const char* m){ perror(m); exit(1); }

// --------- User-configurable knobs (autofilled by generator) ----------
static const int IB_PORT = 1;
static const int MSG_SIZE = 1024;
static const char* BUNDLE_ENV = "RDMA_FUZZ_RUNTIME";
static const char* CLIENT_UPDATE_PATH = "client_update.json";

// --------- Prolog helper (optional; you can keep minimal) -------------
char bufs[1024][1024];
struct ibv_device ** dev_list;
struct ibv_context * ctx;
struct ibv_device_attr dev_attr;
struct ibv_port_attr port_attr;
union ibv_gid gid;
struct ibv_cq * cq1 = NULL;
struct ibv_pd * pd1 = NULL;
struct ibv_mr * mr1 = NULL;
struct ibv_mr * mr_53931 = NULL;
struct ibv_dm * dm1;
struct ibv_dm * dm_8944;
struct ibv_mr * mr_49453 = NULL;
struct ibv_pd * pd_1206 = NULL;
struct ibv_dm * dm_25861;
struct ibv_alloc_dm_attr dm_attr_dm1;
struct ibv_modify_cq_attr modify_cq_attr;
struct ibv_moderate_cq modify_cq_attr_moderate;
struct ibv_alloc_dm_attr dm_attr_dm_8944;
struct ibv_alloc_dm_attr dm_attr_dm_25861;

// --- Prepare PR_* for CLAIMED ---
PR_QP  qps[1000];
PR_MR  mrs[1000];
PR_Pair prs[1000];
int  qps_size;
int  mrs_size;
int  prs_size;

// ---------------------- main ----------------------
int main(int argc, char** argv){
    pr_init(BUNDLE_ENV);

    // --- Local buffers / MRs / QPs (generated) ---
    /* setup generated by verbs (alloc/reg/create) moved here if你把这些也用 generate_c 产出 */

    // --- Optional early verbs (don’t need remote params; e.g., PostRecv) ---
    

    // --- Main verbs body (generated) ---
    
    /* ibv_get_device_list */
    dev_list = ibv_get_device_list(NULL);
    if (!dev_list) {
        fprintf(stderr, "Failed to get device list: %s\n", strerror(errno));
        return -1;
    }

    /* ibv_open_device */
    ctx = ibv_open_device(dev_list[0]);
    if (!ctx) {
        fprintf(stderr, "Failed to open device\n");
        return -1;
    }

    /* ibv_free_device_list */
    ibv_free_device_list(dev_list);

    /* ibv_query_device */
    if (ibv_query_device(ctx, &dev_attr)) {
        fprintf(stderr, "Failed to query device attributes\n");
        return -1;
    }

    /* ibv_query_port */
    if (ibv_query_port(ctx, 1, &port_attr)) {
        fprintf(stderr, "Failed to query port attributes\n");
        return -1;
    }

    /* ibv_query_gid */
    if (ibv_query_gid(ctx, 1, 0, &gid)) {
        fprintf(stderr, "Failed to query GID\n");
        return -1;
    }

    /* ibv_create_cq */
    cq1 = ibv_create_cq(ctx, 32, 
                              NULL, NULL, 
                              0);
    if (!cq1) {
        fprintf(stderr, "Failed to create completion queue\n");
        return -1;
    }

    /* ibv_alloc_pd */
    pd1 = ibv_alloc_pd(ctx);
    if (!pd1) {
        fprintf(stderr, "Failed to allocate protection domain\n");
        return -1;
    }

    /* ibv_reg_mr */
    mr1 = ibv_reg_mr(pd1, bufs[0], 1024, IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE);
    if (!mr1) {
        fprintf(stderr, "Failed to register memory region\n");
        return -1;
    }
    
    mrs[mrs_size++] = (PR_MR){
        .id = "mr1",
        .addr = (uint64_t)(mr1->addr),
        .length = 1024,
        .lkey = mr1->lkey};
        
    pr_write_client_update_claimed(CLIENT_UPDATE_PATH, qps, qps_size, mrs, mrs_size, prs, prs_size);
    

    /* ibv_reg_mr */
    mr_53931 = ibv_reg_mr(pd1, buf0, 4096, IBV_ACCESS_LOCAL_WRITE);
    if (!mr_53931) {
        fprintf(stderr, "Failed to register memory region\n");
        return -1;
    }
    
    mrs[mrs_size++] = (PR_MR){
        .id = "mr_53931",
        .addr = (uint64_t)(mr_53931->addr),
        .length = 1024,
        .lkey = mr_53931->lkey};
        
    pr_write_client_update_claimed(CLIENT_UPDATE_PATH, qps, qps_size, mrs, mrs_size, prs, prs_size);
    

    memset(&dm_attr_dm1, 0, sizeof(dm_attr_dm1));
    dm_attr_dm1.length = 4096;
    dm_attr_dm1.log_align_req = 12;
    dm_attr_dm1.comp_mask = 0;

    dm1 = ibv_alloc_dm(ctx, &dm_attr_dm1);
    if (!dm1) {
        fprintf(stderr, "Failed to allocate device memory (DM)\n");
        return -1;
    }

        /* ibv_poll_cq — self-contained minimal polling */
        {
            struct ibv_wc wc;
            int n = 0;
            int attempts = 100;   /* ~100 * 100us ≈ 10ms */
            while (attempts-- > 0) {
                n = ibv_poll_cq(cq1, 1, &wc);
                if (n < 0) {
                    fprintf(stderr, "ibv_poll_cq failed\n");
                    return -1;
                }
                if (n == 1) {
                    if (wc.status != IBV_WC_SUCCESS) {
                        fprintf(stderr, "bad completion: status=0x%x vendor=0x%x\n",
                                wc.status, wc.vendor_err);
                        return -1;
                    }
                    /* success – got one completion */
                    break;
                }
                /* n == 0: no CQE yet, back off briefly */
                usleep(100); /* 100us */
            }
            if (n == 0) {
                fprintf(stderr, "no completion within budget\n");
                return -1;
            }
        }
    
    /* ibv_free_dm */
    if (ibv_free_dm(dm1)) {
        fprintf(stderr, "Failed to free device memory (DM)\n");
        return -1;
    }

        /* ibv_poll_cq — self-contained minimal polling */
        {
            struct ibv_wc wc;
            int n = 0;
            int attempts = 100;   /* ~100 * 100us ≈ 10ms */
            while (attempts-- > 0) {
                n = ibv_poll_cq(cq1, 1, &wc);
                if (n < 0) {
                    fprintf(stderr, "ibv_poll_cq failed\n");
                    return -1;
                }
                if (n == 1) {
                    if (wc.status != IBV_WC_SUCCESS) {
                        fprintf(stderr, "bad completion: status=0x%x vendor=0x%x\n",
                                wc.status, wc.vendor_err);
                        return -1;
                    }
                    /* success – got one completion */
                    break;
                }
                /* n == 0: no CQE yet, back off briefly */
                usleep(100); /* 100us */
            }
            if (n == 0) {
                fprintf(stderr, "no completion within budget\n");
                return -1;
            }
        }
    
    memset(&modify_cq_attr, 0, sizeof(modify_cq_attr));
    modify_cq_attr.attr_mask = 0;

    memset(&modify_cq_attr_moderate, 0, sizeof(modify_cq_attr_moderate));
    modify_cq_attr_moderate.cq_count = 1;
    modify_cq_attr_moderate.cq_period = 1;
    modify_cq_attr.moderate = modify_cq_attr_moderate;

    if (ibv_modify_cq(cq1, &modify_cq_attr) != 0) {
        fprintf(stderr, "ibv_modify_cq failed\n");
        return -1;
    }

    memset(&modify_cq_attr, 0, sizeof(modify_cq_attr));
    modify_cq_attr.attr_mask = 0;

    memset(&modify_cq_attr_moderate, 0, sizeof(modify_cq_attr_moderate));
    modify_cq_attr_moderate.cq_count = 1;
    modify_cq_attr_moderate.cq_period = 1;
    modify_cq_attr.moderate = modify_cq_attr_moderate;

    if (ibv_modify_cq(cq1, &modify_cq_attr) != 0) {
        fprintf(stderr, "ibv_modify_cq failed\n");
        return -1;
    }

    memset(&dm_attr_dm_8944, 0, sizeof(dm_attr_dm_8944));
    dm_attr_dm_8944.length = 8192;
    dm_attr_dm_8944.log_align_req = 64;
    dm_attr_dm_8944.comp_mask = 0;

    dm_8944 = ibv_alloc_dm(ctx, &dm_attr_dm_8944);
    if (!dm_8944) {
        fprintf(stderr, "Failed to allocate device memory (DM)\n");
        return -1;
    }

    memset(&modify_cq_attr, 0, sizeof(modify_cq_attr));
    modify_cq_attr.attr_mask = 0;

    memset(&modify_cq_attr_moderate, 0, sizeof(modify_cq_attr_moderate));
    modify_cq_attr_moderate.cq_count = 1;
    modify_cq_attr_moderate.cq_period = 1;
    modify_cq_attr.moderate = modify_cq_attr_moderate;

    if (ibv_modify_cq(cq1, &modify_cq_attr) != 0) {
        fprintf(stderr, "ibv_modify_cq failed\n");
        return -1;
    }

    /* ibv_reg_mr */
    mr_49453 = ibv_reg_mr(pd1, buf0, 4096, IBV_ACCESS_LOCAL_WRITE);
    if (!mr_49453) {
        fprintf(stderr, "Failed to register memory region\n");
        return -1;
    }
    
    mrs[mrs_size++] = (PR_MR){
        .id = "mr_49453",
        .addr = (uint64_t)(mr_49453->addr),
        .length = 1024,
        .lkey = mr_49453->lkey};
        
    pr_write_client_update_claimed(CLIENT_UPDATE_PATH, qps, qps_size, mrs, mrs_size, prs, prs_size);
    

    /* ibv_alloc_pd */
    pd_1206 = ibv_alloc_pd(ctx);
    if (!pd_1206) {
        fprintf(stderr, "Failed to allocate protection domain\n");
        return -1;
    }

    /* ibv_free_dm */
    if (ibv_free_dm(dm_8944)) {
        fprintf(stderr, "Failed to free device memory (DM)\n");
        return -1;
    }

    memset(&modify_cq_attr, 0, sizeof(modify_cq_attr));
    modify_cq_attr.attr_mask = 0;

    memset(&modify_cq_attr_moderate, 0, sizeof(modify_cq_attr_moderate));
    modify_cq_attr_moderate.cq_count = 1;
    modify_cq_attr_moderate.cq_period = 1;
    modify_cq_attr.moderate = modify_cq_attr_moderate;

    if (ibv_modify_cq(cq1, &modify_cq_attr) != 0) {
        fprintf(stderr, "ibv_modify_cq failed\n");
        return -1;
    }

    memset(&dm_attr_dm_25861, 0, sizeof(dm_attr_dm_25861));
    dm_attr_dm_25861.length = 8192;
    dm_attr_dm_25861.log_align_req = 64;

    dm_25861 = ibv_alloc_dm(ctx, &dm_attr_dm_25861);
    if (!dm_25861) {
        fprintf(stderr, "Failed to allocate device memory (DM)\n");
        return -1;
    }


    // --- Optional CQ polling / cleanup (generated or static) ---
    /* optional CQ polling & cleanup */

    return 0;
}