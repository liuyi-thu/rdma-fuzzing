// AUTOGEN: RDMA client (pairs + runtime) — generated by your fuzzer
// Toolchain: g++ -O2 -std=c++17 pair_runtime.cpp runtime_resolver.c -lcjson -libverbs -pthread -o rdma_client_autogen

#include <infiniband/verbs.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <thread>
#include <vector>
#include <string>
#include <algorithm>
#include <unistd.h>

#include "pair_runtime.h"
#include "runtime_resolver.h"

using std::string;
using std::vector;

static void die(const char *m)
{
    perror(m);
    exit(1);
}

// --------- User-configurable knobs (autofilled by generator) ----------
static const int IB_PORT = 1;
static const int MSG_SIZE = 1024;
static const char *BUNDLE_ENV = "RDMA_FUZZ_RUNTIME";
static const char *CLIENT_UPDATE_PATH = "client_update.json";

// --------- Prolog helper (optional; you can keep minimal) -------------
char bufs[1024][1024];
struct ibv_device **dev_list;
struct ibv_context *ctx;
struct ibv_device_attr dev_attr;
struct ibv_port_attr port_attr;
union ibv_gid gid;
struct ibv_dm *dm0;
struct ibv_pd *pd1 = NULL;
struct ibv_dm *dm_61334;
struct ibv_cq *cq1 = NULL;
struct ibv_pd *pd_47248 = NULL;
struct ibv_mr *mr1 = NULL;
struct ibv_dm *dm_13388;
struct ibv_cq *cq_29656 = NULL;
struct ibv_cq *cq_37133 = NULL;
struct ibv_mw *mw_60800;
struct ibv_pd *pd_37095 = NULL;
struct ibv_qp *qp_17856 = NULL;
struct ibv_mr *mr_39021 = NULL;
struct ibv_pd *pd_7294 = NULL;
struct ibv_pd *pd_61895 = NULL;
struct ibv_alloc_dm_attr dm_attr_dm0;
struct ibv_alloc_dm_attr dm_attr_dm_61334;
struct ibv_alloc_dm_attr dm_attr_dm_13388;
struct ibv_qp_init_attr attr_init_qp_17856;
struct ibv_qp_cap attr_init_qp_17856_cap;
struct ibv_send_wr wr_qp_17856;
struct ibv_sge wr_qp_17856_sge_0;
struct ibv_send_wr *bad_wr_qp_17856 = NULL;
struct ibv_mw_bind mw_bind_mw_60800;
struct ibv_mw_bind_info mw_bind_mw_60800_bind_info;

// --- Prepare PR_* for CLAIMED ---
PR_QP qps[1000];
PR_MR mrs[1000];
PR_Pair prs[1000];
int qps_size;
int mrs_size;
int prs_size;

// ---------------------- main ----------------------
int main(int argc, char **argv)
{
    pr_init(BUNDLE_ENV);

    // --- Local buffers / MRs / QPs (generated) ---
    /* setup generated by verbs (alloc/reg/create) moved here if你把这些也用 generate_c 产出 */

    // --- Optional early verbs (don’t need remote params; e.g., PostRecv) ---

    // --- Main verbs body (generated) ---

    /* ibv_get_device_list */
    dev_list = ibv_get_device_list(NULL);
    if (!dev_list)
    {
        fprintf(stderr, "Failed to get device list: %s\n", strerror(errno));
        return -1;
    }

    /* ibv_open_device */
    ctx = ibv_open_device(dev_list[0]);
    if (!ctx)
    {
        fprintf(stderr, "Failed to open device\n");
        return -1;
    }

    /* ibv_free_device_list */
    ibv_free_device_list(dev_list);

    /* ibv_query_device */
    if (ibv_query_device(ctx, &dev_attr))
    {
        fprintf(stderr, "Failed to query device attributes\n");
        return -1;
    }

    /* ibv_query_port */
    if (ibv_query_port(ctx, 1, &port_attr))
    {
        fprintf(stderr, "Failed to query port attributes\n");
        return -1;
    }

    /* ibv_query_gid */
    if (ibv_query_gid(ctx, 1, 1, &gid))
    {
        fprintf(stderr, "Failed to query GID\n");
        return -1;
    }

    // memset(&dm_attr_dm0, 0, sizeof(dm_attr_dm0));
    // dm_attr_dm0.length = 4096;
    // dm_attr_dm0.log_align_req = 12;

    // dm0 = ibv_alloc_dm(ctx, &dm_attr_dm0);
    // if (!dm0) {
    //     fprintf(stderr, "Failed to allocate device memory (DM)\n");
    //     return -1;
    // }

    /* ibv_alloc_pd */
    pd1 = ibv_alloc_pd(ctx);
    if (!pd1)
    {
        fprintf(stderr, "Failed to allocate protection domain\n");
        return -1;
    }

    // /* ibv_free_dm */
    // if (ibv_free_dm(dm0)) {
    //     fprintf(stderr, "Failed to free device memory (DM)\n");
    //     return -1;
    // }

    // memset(&dm_attr_dm_61334, 0, sizeof(dm_attr_dm_61334));
    // dm_attr_dm_61334.length = 8192;
    // dm_attr_dm_61334.log_align_req = 64;

    // dm_61334 = ibv_alloc_dm(ctx, &dm_attr_dm_61334);
    // if (!dm_61334) {
    //     fprintf(stderr, "Failed to allocate device memory (DM)\n");
    //     return -1;
    // }

    /* ibv_create_cq */
    cq1 = ibv_create_cq(ctx, 32,
                        NULL, NULL,
                        0);
    if (!cq1)
    {
        fprintf(stderr, "Failed to create completion queue\n");
        return -1;
    }

    /* ibv_alloc_pd */
    pd_47248 = ibv_alloc_pd(ctx);
    if (!pd_47248)
    {
        fprintf(stderr, "Failed to allocate protection domain\n");
        return -1;
    }

    /* ibv_reg_mr */
    mr1 = ibv_reg_mr(pd1, bufs[1], 1024, IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE);
    if (!mr1)
    {
        fprintf(stderr, "Failed to register memory region\n");
        return -1;
    }

    mrs[mrs_size++] = (PR_MR){
        .id = "mr1",
        .addr = (uint64_t)(mr1->addr),
        .length = 1024,
        .lkey = mr1->lkey};

    pr_write_client_update_claimed(CLIENT_UPDATE_PATH, qps, qps_size, mrs, mrs_size, prs, prs_size);

    // memset(&dm_attr_dm_13388, 0, sizeof(dm_attr_dm_13388));
    // dm_attr_dm_13388.length = 8192;
    // dm_attr_dm_13388.log_align_req = 64;

    // dm_13388 = ibv_alloc_dm(ctx, &dm_attr_dm_13388);
    // if (!dm_13388) {
    //     fprintf(stderr, "Failed to allocate device memory (DM)\n");
    //     return -1;
    // }

    /* ibv_free_dm */
    // if (ibv_free_dm(dm_13388)) {
    //     fprintf(stderr, "Failed to free device memory (DM)\n");
    //     return -1;
    // }

    /* ibv_create_cq */
    cq_29656 = ibv_create_cq(ctx, 16,
                             NULL, NULL,
                             0);
    if (!cq_29656)
    {
        fprintf(stderr, "Failed to create completion queue\n");
        return -1;
    }

    // /* ibv_dealloc_pd */
    // if (ibv_dealloc_pd(pd1))
    // {
    //     fprintf(stderr, "Failed to deallocate PD \n");
    //     return -1;
    // }

    /* ibv_create_cq */
    cq_37133 = ibv_create_cq(ctx, 16,
                             NULL, NULL,
                             0);
    if (!cq_37133)
    {
        fprintf(stderr, "Failed to create completion queue\n");
        return -1;
    }

    /* ibv_alloc_mw */
    mw_60800 = ibv_alloc_mw(pd_47248, IBV_MW_TYPE_1);
    if (!mw_60800)
    {
        fprintf(stderr, "Failed to allocate memory window\n");
        return -1;
    }

    /* ibv_alloc_pd */
    pd_37095 = ibv_alloc_pd(ctx);
    if (!pd_37095)
    {
        fprintf(stderr, "Failed to allocate protection domain\n");
        return -1;
    }

    /* ibv_create_qp */

    memset(&attr_init_qp_17856, 0, sizeof(attr_init_qp_17856));
    attr_init_qp_17856.send_cq = cq_37133;
    attr_init_qp_17856.recv_cq = cq_29656;

    memset(&attr_init_qp_17856_cap, 0, sizeof(attr_init_qp_17856_cap));
    attr_init_qp_17856_cap.max_send_wr = 1;
    attr_init_qp_17856_cap.max_recv_wr = 1;
    attr_init_qp_17856_cap.max_send_sge = 1;
    attr_init_qp_17856_cap.max_recv_sge = 1;
    attr_init_qp_17856.cap = attr_init_qp_17856_cap;
    attr_init_qp_17856.qp_type = IBV_QPT_RC;

    qp_17856 = ibv_create_qp(pd_37095, &attr_init_qp_17856);
    if (!qp_17856)
    {
        fprintf(stderr, "Failed to create QP\n");
        return -1;
    }

    qps[qps_size++] = (PR_QP){
        .id = "qp_17856",
        .qpn = qp_17856->qp_num,
        .psn = 0,
        .port = 1,
        .lid = 0,
        .gid = "" // will set below
    };

    snprintf(qps[qps_size - 1].gid, sizeof(qps[qps_size - 1].gid),
             "%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x",
             gid.raw[0], gid.raw[1], gid.raw[2], gid.raw[3], gid.raw[4], gid.raw[5], gid.raw[6], gid.raw[7], gid.raw[8], gid.raw[9], gid.raw[10], gid.raw[11], gid.raw[12], gid.raw[13], gid.raw[14], gid.raw[15]);

    prs[prs_size++] = (PR_Pair){
        .id = "pair-qp_17856-srv0",
        .cli_id = "qp_17856",
        .srv_id = "srv0"};

    pr_write_client_update_claimed(CLIENT_UPDATE_PATH, qps, qps_size, mrs, mrs_size, prs, prs_size);

    /* ibv_reg_mr */
    mr_39021 = ibv_reg_mr(pd_47248, bufs[12], 4096, IBV_ACCESS_LOCAL_WRITE);
    if (!mr_39021)
    {
        fprintf(stderr, "Failed to register memory region\n");
        return -1;
    }

    mrs[mrs_size++] = (PR_MR){
        .id = "mr_39021",
        .addr = (uint64_t)(mr_39021->addr),
        .length = 1024,
        .lkey = mr_39021->lkey};

    pr_write_client_update_claimed(CLIENT_UPDATE_PATH, qps, qps_size, mrs, mrs_size, prs, prs_size);

    /* ibv_alloc_pd */
    pd_7294 = ibv_alloc_pd(ctx);
    if (!pd_7294)
    {
        fprintf(stderr, "Failed to allocate protection domain\n");
        return -1;
    }

    /* ibv_poll_cq — self-contained minimal polling */
    {
        struct ibv_wc wc;
        int n = 0;
        int attempts = 100; /* ~100 * 100us ≈ 10ms */
        while (attempts-- > 0)
        {
            n = ibv_poll_cq(cq_37133, 1, &wc);
            if (n < 0)
            {
                fprintf(stderr, "ibv_poll_cq failed\n");
                return -1;
            }
            if (n == 1)
            {
                if (wc.status != IBV_WC_SUCCESS)
                {
                    fprintf(stderr, "bad completion: status=0x%x vendor=0x%x\n",
                            wc.status, wc.vendor_err);
                    return -1;
                }
                /* success – got one completion */
                break;
            }
            /* n == 0: no CQE yet, back off briefly */
            usleep(100); /* 100us */
        }
        if (n == 0)
        {
            fprintf(stderr, "no completion within budget\n");
            return -1;
        }
    }

    /* ibv_alloc_pd */
    pd_61895 = ibv_alloc_pd(ctx);
    if (!pd_61895)
    {
        fprintf(stderr, "Failed to allocate protection domain\n");
        return -1;
    }

    /* ibv_post_send */

    memset(&wr_qp_17856, 0, sizeof(wr_qp_17856));

    memset(&wr_qp_17856_sge_0, 0, sizeof(wr_qp_17856_sge_0));
    wr_qp_17856_sge_0.addr = (uint64_t)mr_39021->addr;
    wr_qp_17856_sge_0.length = mr_39021->length;
    wr_qp_17856_sge_0.lkey = mr_39021->lkey;
    wr_qp_17856.sg_list = &wr_qp_17856_sge_0;
    wr_qp_17856.num_sge = 1;
    wr_qp_17856.opcode = IBV_WR_SEND;

    if (ibv_post_send(qp_17856, &wr_qp_17856, &bad_wr_qp_17856) != 0)
    {
        fprintf(stderr, "Failed to post send work request\n");
        return -1;
    }

    memset(&mw_bind_mw_60800, 0, sizeof(mw_bind_mw_60800));

    memset(&mw_bind_mw_60800_bind_info, 0, sizeof(mw_bind_mw_60800_bind_info));
    mw_bind_mw_60800_bind_info.addr = 0;
    mw_bind_mw_60800_bind_info.length = 4096;
    mw_bind_mw_60800_bind_info.mw_access_flags = 0;
    mw_bind_mw_60800_bind_info.mr = mr_39021;
    mw_bind_mw_60800.bind_info = mw_bind_mw_60800_bind_info;

    if (ibv_bind_mw(qp_17856, mw_60800, &mw_bind_mw_60800) != 0)
    {
        fprintf(stderr, "Failed to bind MW\n");
        return -1;
    }

    // --- Optional CQ polling / cleanup (generated or static) ---
    /* optional CQ polling & cleanup */

    return 0;
}