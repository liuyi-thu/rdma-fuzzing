// AUTOGEN: RDMA client (pairs + runtime) — generated by your fuzzer
// Toolchain: g++ -O2 -std=c++17 pair_runtime.cpp runtime_resolver.c -lcjson -libverbs -pthread -o rdma_client_autogen

#include <infiniband/verbs.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <thread>
#include <vector>
#include <string>
#include <algorithm>
#include <unistd.h>

#include "pair_runtime.h"
#include "runtime_resolver.h"

using std::string;
using std::vector;

/* ---- fuzz-friendly guards ---- */
static inline int res_ok_ptr(const void *p, const char *what) {
    if (!p) {
        fprintf(stderr, "[skip] missing resource: %s\n", what);
        return 0;
    }
    return 1;
}

#define IF_OK_PTR(p, ...)                            \
    do {                                             \
        if (res_ok_ptr((p), #p)) {                   \
            __VA_ARGS__                              \
        }                                            \
    } while (0)

/* 布尔哨兵变量帮助宏：声明、置位 */
#define DECL_OK(name)   int ok_##name = 0
#define SET_OK(name,v)  do { ok_##name = ((v) != NULL); } while (0)
#define IF_OK(name, CODE_BLOCK) \
    do { if (ok_##name) { CODE_BLOCK } } while (0)

static void die(const char* m){ perror(m); exit(1); }

// --------- User-configurable knobs (autofilled by generator) ----------
static const int IB_PORT = 1;
static const int MSG_SIZE = 1024;
static const char* BUNDLE_ENV = "RDMA_FUZZ_RUNTIME";
static const char* CLIENT_UPDATE_PATH = "client_update.json";

// --------- Prolog helper (optional; you can keep minimal) -------------
char bufs[1024][1024];
struct ibv_device ** dev_list;
struct ibv_context * ctx;
struct ibv_device_attr dev_attr;
struct ibv_port_attr port_attr;
union ibv_gid gid;
struct ibv_pd * pd0 = NULL;
struct ibv_pd * pd1 = NULL;
struct ibv_dm * dm0;
struct ibv_srq * srq0;
struct ibv_cq * cq0 = NULL;
struct ibv_cq * cq1 = NULL;
struct ibv_mr * mr0 = NULL;
struct ibv_mr * mr1 = NULL;
struct ibv_dm * dm1;
struct ibv_mr * mr_42720 = NULL;
struct ibv_alloc_dm_attr dm_attr_dm0;
struct ibv_srq_init_attr srq_init_attr_0;
struct ibv_srq_attr srq_init_attr_0_attr;
struct ibv_modify_cq_attr modify_cq_attr;
struct ibv_alloc_dm_attr dm_attr_dm1;
struct ibv_srq_attr srq_attr_srq0;
struct ibv_recv_wr recv_wr_srq0;
struct ibv_sge recv_wr_srq0_sge_0;
struct ibv_recv_wr * bad_recv_wr_srq0 = NULL;

// --- Prepare PR_* for CLAIMED ---
PR_QP  qps[1000];
PR_MR  mrs[1000];
PR_Pair prs[1000];
int  qps_size;
int  mrs_size;
int  prs_size;

// ---------------------- main ----------------------
int main(int argc, char** argv){
    pr_init(BUNDLE_ENV);

    // --- Local buffers / MRs / QPs (generated) ---
    /* setup generated by verbs (alloc/reg/create) moved here if你把这些也用 generate_c 产出 */

    // --- Optional early verbs (don’t need remote params; e.g., PostRecv) ---
    

    // --- Main verbs body (generated) ---
        printf("[1] GetDeviceList(dev_list=dev_list) start.\n");

    /* ibv_get_device_list */
    dev_list = ibv_get_device_list(NULL);
    if (!dev_list) {
        fprintf(stderr, "Failed to get device list: %s\n", strerror(errno));
        return -1;
    }
    printf("[1] done.\n");

    printf("[2] OpenDevice(device=dev_list) start.\n");

    /* ibv_open_device */
    ctx = ibv_open_device(dev_list[0]);
    if (!ctx) {
        fprintf(stderr, "Failed to open device dev_list\n");
    }
    printf("[2] done.\n");

    printf("[3] FreeDeviceList(dev_list=dev_list, context=<lib.codegen_context.CodeGenContext object at...) start.\n");

    /* ibv_free_device_list */
    ibv_free_device_list(dev_list);
    printf("[3] done.\n");

    printf("[4] QueryDeviceAttr(output=dev_attr) start.\n");

    /* ibv_query_device */
    if (ibv_query_device(ctx, &dev_attr)) {
        fprintf(stderr, "Failed to query device attributes\n");
        return -1;
    }
    printf("[4] done.\n");

    printf("[5] QueryPortAttr(port_num=1) start.\n");

    /* ibv_query_port */
    if (ibv_query_port(ctx, 1, &port_attr)) {
        fprintf(stderr, "Failed to query port attributes\n");
        return -1;
    }
    printf("[5] done.\n");

    printf("[6] QueryGID(port_num=1, index=1) start.\n");

    /* ibv_query_gid */
    if (ibv_query_gid(ctx, 1, 1, &gid)) {
        fprintf(stderr, "Failed to query GID\n");
        return -1;
    }
    printf("[6] done.\n");

    printf("[7] AllocPD(pd=pd0) start.\n");

    /* ibv_alloc_pd */
    pd0 = ibv_alloc_pd(ctx);
    if (!pd0) {
        fprintf(stderr, "Failed to allocate protection domain pd0\n");
    }
    printf("[7] done.\n");

    printf("[8] AllocPD(pd=pd1) start.\n");

    /* ibv_alloc_pd */
    pd1 = ibv_alloc_pd(ctx);
    if (!pd1) {
        fprintf(stderr, "Failed to allocate protection domain pd1\n");
    }
    printf("[8] done.\n");

    printf("[9] AllocDM(dm=dm0, attr_obj=IbvAllocDmAttr{length=4096, log_align_req=12}, attr_var=dm_attr_dm0) start.\n");

    memset(&dm_attr_dm0, 0, sizeof(dm_attr_dm0));
    dm_attr_dm0.length = 4096;
    dm_attr_dm0.log_align_req = 12;

    dm0 = ibv_alloc_dm(ctx, &dm_attr_dm0);
    if (!dm0) {
        fprintf(stderr, "Failed to allocate device memory (DM) dm0\n");
    }
    printf("[9] done.\n");

    printf("[10] CreateSRQ(pd=pd0, srq=srq0, srq_init_obj=IbvSrqInitAttr{attr=IbvSrqAttr{}}) start.\n");

    /* ibv_create_srq */
    IF_OK_PTR(pd0, {
        
    memset(&srq_init_attr_0, 0, sizeof(srq_init_attr_0));

    memset(&srq_init_attr_0_attr, 0, sizeof(srq_init_attr_0_attr));
    srq_init_attr_0.attr = srq_init_attr_0_attr;

        srq0 = ibv_create_srq(pd0, &srq_init_attr_0);
        if (!srq0) {
            fprintf(stderr, "Failed to create SRQ srq0\n");
        }
    });
    printf("[10] done.\n");

    printf("[11] CreateCQ(cqe=32, cq_context=NULL, channel=NULL, comp_vector=0, cq=cq0) start.\n");

    /* ibv_create_cq */
    cq0 = ibv_create_cq(ctx, 32, 
                              NULL, NULL, 
                              0);
    if (!cq0) {
        fprintf(stderr, "Failed to create completion queue cq0\n");
    }
    printf("[11] done.\n");

    printf("[12] CreateCQ(cqe=32, cq_context=NULL, channel=NULL, comp_vector=0, cq=cq1) start.\n");

    /* ibv_create_cq */
    cq1 = ibv_create_cq(ctx, 32, 
                              NULL, NULL, 
                              0);
    if (!cq1) {
        fprintf(stderr, "Failed to create completion queue cq1\n");
    }
    printf("[12] done.\n");

    printf("[13] ModifyCQ(cq=cq0, attr_obj=IbvModifyCQAttr{}, attr_var=modify_cq_attr) start.\n");

    memset(&modify_cq_attr, 0, sizeof(modify_cq_attr));

    IF_OK_PTR(cq0, {
        if (ibv_modify_cq(cq0, &modify_cq_attr) != 0) {
            fprintf(stderr, "ibv_modify_cq failed cq0\n");
        }
    });
    printf("[13] done.\n");

    printf("[14] RegMR(pd=pd0, mr=mr0, addr=bufs[0], length=1024, access=IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_RE...) start.\n");

    /* ibv_reg_mr */
    mr0 = ibv_reg_mr(pd0, bufs[0], 1024, IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE);
    if (!mr0) {
        fprintf(stderr, "Failed to register memory region mr0\n");
    }
    
    IF_OK_PTR(mr0, {
        mrs[mrs_size++] = (PR_MR){
            .id = "mr0",
            .addr = (uint64_t)(mr0->addr),
            .length = 1024,
            .lkey = mr0->lkey
        };
        pr_write_client_update_claimed(CLIENT_UPDATE_PATH, qps, qps_size, mrs, mrs_size, prs, prs_size);
    });
    
    printf("[14] done.\n");

    printf("[15] RegMR(pd=pd1, mr=mr1, addr=bufs[1], length=1024, access=IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_RE...) start.\n");

    /* ibv_reg_mr */
    mr1 = ibv_reg_mr(pd1, bufs[1], 1024, IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_READ | IBV_ACCESS_REMOTE_WRITE);
    if (!mr1) {
        fprintf(stderr, "Failed to register memory region mr1\n");
    }
    
    IF_OK_PTR(mr1, {
        mrs[mrs_size++] = (PR_MR){
            .id = "mr1",
            .addr = (uint64_t)(mr1->addr),
            .length = 1024,
            .lkey = mr1->lkey
        };
        pr_write_client_update_claimed(CLIENT_UPDATE_PATH, qps, qps_size, mrs, mrs_size, prs, prs_size);
    });
    
    printf("[15] done.\n");

    printf("[16] AllocDM(dm=dm1, attr_obj=IbvAllocDmAttr{length=4096, log_align_req=12}, attr_var=dm_attr_dm1) start.\n");

    memset(&dm_attr_dm1, 0, sizeof(dm_attr_dm1));
    dm_attr_dm1.length = 4096;
    dm_attr_dm1.log_align_req = 12;

    dm1 = ibv_alloc_dm(ctx, &dm_attr_dm1);
    if (!dm1) {
        fprintf(stderr, "Failed to allocate device memory (DM) dm1\n");
    }
    printf("[16] done.\n");

    printf("[17] ModifySRQ(srq=srq0, attr_var=srq_attr_srq0, attr_obj=IbvSrqAttr{max_wr=1025, max_sge=1}, attr_mask=0) start.\n");

    memset(&srq_attr_srq0, 0, sizeof(srq_attr_srq0));
    srq_attr_srq0.max_wr = 1025;
    srq_attr_srq0.max_sge = 1;

    IF_OK_PTR(srq0, {
        if (ibv_modify_srq(srq0, &srq_attr_srq0, 0) != 0) {
            fprintf(stderr, "ibv_modify_srq failed srq0\n");
        }
    });
    printf("[17] done.\n");

    printf("[18] PostSRQRecv(srq=srq0, wr_obj=IbvRecvWR{num_sge=1, sg_list=[IbvSge x1: IbvSge{addr=\u2205, length=\u2205, lkey=\u2205}], wr_id=1}, wr_var=recv_wr_srq0, bad_wr_var=bad_recv_wr_srq0) start.\n");

    /* ibv_post_srq_recv (fuzz-friendly guarded) */
    IF_OK_PTR(srq0, {

    memset(&recv_wr_srq0, 0, sizeof(recv_wr_srq0));
    recv_wr_srq0.wr_id = 1;

    memset(&recv_wr_srq0_sge_0, 0, sizeof(recv_wr_srq0_sge_0));
    recv_wr_srq0.sg_list = &recv_wr_srq0_sge_0;
    recv_wr_srq0.num_sge = 1;
    recv_wr_srq0.next = NULL;
    if (ibv_post_srq_recv(srq0, &recv_wr_srq0, &bad_recv_wr_srq0) != 0) {
        fprintf(stderr, "[warn] ibv_post_srq_recv failed srq0\n");
    }
    });

    printf("[18] done.\n");

    printf("[19] PollCQ(cq=cq0) start.\n");

        /* ibv_poll_cq — self-contained minimal polling */
        IF_OK_PTR(cq0, {
            {
                struct ibv_wc wc;
                int n = 0;
                int attempts = 100;   /* ~100 * 100us ≈ 10ms */
                while (attempts-- > 0) {
                    n = ibv_poll_cq(cq0, 1, &wc);
                    if (n < 0) {
                        fprintf(stderr, "ibv_poll_cq failed\n");
                    }
                    if (n == 1) {
                        if (wc.status != IBV_WC_SUCCESS) {
                            fprintf(stderr, "bad completion: status=0x%x vendor=0x%x\n",
                                    wc.status, wc.vendor_err);
                        }
                        /* success – got one completion */
                        break;
                    }
                    /* n == 0: no CQE yet, back off briefly */
                    usleep(100); /* 100us */
                }
                if (n == 0) {
                    fprintf(stderr, "no completion within budget\n");
                }
            }
        });

        printf("[19] done.\n");

    printf("[20] RegMR(pd=pd1, mr=mr_42720, addr=bufs[70], length=4096, access=IBV_ACCESS_LOCAL_WRITE) start.\n");

    /* ibv_reg_mr */
    mr_42720 = ibv_reg_mr(pd1, bufs[70], 4096, IBV_ACCESS_LOCAL_WRITE);
    if (!mr_42720) {
        fprintf(stderr, "Failed to register memory region mr_42720\n");
    }
    
    IF_OK_PTR(mr_42720, {
        mrs[mrs_size++] = (PR_MR){
            .id = "mr_42720",
            .addr = (uint64_t)(mr_42720->addr),
            .length = 4096,
            .lkey = mr_42720->lkey
        };
        pr_write_client_update_claimed(CLIENT_UPDATE_PATH, qps, qps_size, mrs, mrs_size, prs, prs_size);
    });
    
    printf("[20] done.\n");

    printf("[21] DestroyCQ(cq=cq0) start.\n");

    /* ibv_destroy_cq */
    IF_OK_PTR(cq0, {
        if (ibv_destroy_cq(cq0)) {
            fprintf(stderr, "Failed to destroy CQ cq0\n");
        }
    });
    printf("[21] done.\n");

    printf("[22] DeregMR(mr=mr0) start.\n");

    /* ibv_dereg_mr */
    IF_OK_PTR(mr0, {
        if (ibv_dereg_mr(mr0)) {
            fprintf(stderr, "Failed to deregister MR mr0\n");
        }
    });
    printf("[22] done.\n");

    printf("[23] ModifySRQ(srq=srq0, attr_var=srq_attr_srq0, attr_obj=IbvSrqAttr{max_wr=1, srq_limit=0}, attr_mask=IBV_SRQ_MAX_WR | IBV_SRQ_LIMIT) start.\n");

    memset(&srq_attr_srq0, 0, sizeof(srq_attr_srq0));
    srq_attr_srq0.max_wr = 1;
    srq_attr_srq0.srq_limit = 0;

    IF_OK_PTR(srq0, {
        if (ibv_modify_srq(srq0, &srq_attr_srq0, IBV_SRQ_MAX_WR | IBV_SRQ_LIMIT) != 0) {
            fprintf(stderr, "ibv_modify_srq failed srq0\n");
        }
    });
    printf("[23] done.\n");

    printf("[24] DestroySRQ(srq=srq0) start.\n");

    /* ibv_destroy_srq */
    IF_OK_PTR(srq0, {
        if (ibv_destroy_srq(srq0) != 0) {
            fprintf(stderr, "Failed to destroy SRQ srq0\n");
        }
    });
    printf("[24] done.\n");

    printf("[25] DeallocPD(pd=pd0) start.\n");

    /* ibv_dealloc_pd */
    IF_OK_PTR(pd0, {
        if (ibv_dealloc_pd(pd0)) {
            fprintf(stderr, "Failed to deallocate PD pd0\n");
        }
    });
    printf("[25] done.\n");

    printf("[26] DestroyCQ(cq=cq1) start.\n");

    /* ibv_destroy_cq */
    IF_OK_PTR(cq1, {
        if (ibv_destroy_cq(cq1)) {
            fprintf(stderr, "Failed to destroy CQ cq1\n");
        }
    });
    printf("[26] done.\n");

    printf("[27] FreeDM(dm=dm0) start.\n");

    /* ibv_free_dm */
    IF_OK_PTR(dm0, {
        if (ibv_free_dm(dm0)) {
            fprintf(stderr, "Failed to free device memory (DM) dm0\n");
        }
    });
    printf("[27] done.\n");



    // --- Optional CQ polling / cleanup (generated or static) ---
    /* optional CQ polling & cleanup */

    return 0;
}